<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sea Catch Scorer</title>
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme Color for PWA Address Bar -->
    <meta name="theme-color" content="#0d6efd">
    <!-- Add Basic Icons for "Add to Home Screen" / PWA -->
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base & Global Styles --- */
        /* ... (keep existing base styles) ... */

        /* --- Page Transitions --- */
        /* ... (keep existing page transitions) ... */

        /* --- Splash Screen --- */
        /* ... (keep existing splash screen styles) ... */

        /* --- Main Content Card Style --- */
        /* ... (keep existing card styles) ... */

        /* --- Page Title Header --- */
        .page-title-header {
            color: #e9ecef;
            font-weight: 600;
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
            margin-top: -10px; /* Adjust as needed */
            padding-left: 0.5rem;
            display: none; /* Hidden initially, shown by JS */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* --- Buttons (General) --- */
        /* ... (keep existing button styles) ... */

        /* --- Floating Action Button (FAB) --- */
        .fab {
            position: fixed;
            bottom: 25px;
            right: 25px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #007bff;
            color: white;
            display: flex; /* Use flexbox for centering icon */
            justify-content: center;
            align-items: center;
            font-size: 2rem; /* Adjust icon size */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1030; /* Below modals but above most content */
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease-out, background-color 0.2s ease;
        }
        .fab:hover {
            background-color: #0056b3;
            transform: scale(1.05);
        }
        .fab:active {
            transform: scale(0.98);
        }
        .fab i {
            line-height: 1; /* Ensure icon is centered vertically */
        }
        .fab.hidden { /* Class to hide FAB */
             display: none;
        }


        /* --- Forms --- */
        /* ... (keep existing form styles) ... */

        /* Length input with +/- buttons adjustments */
        .length-input-group {
            display: flex;
            align-items: center;
            gap: 5px; /* Space between elements */
        }
        .length-input-group .form-control {
            flex-grow: 1; /* Input takes available space */
            min-width: 60px; /* Ensure input doesn't get too small */
            text-align: center;
        }
        .length-input-group .btn-length-adjust {
            flex-shrink: 0; /* Prevent buttons from shrinking */
            width: 40px; /* Fixed width */
            height: 40px; /* Fixed height */
            padding: 0; /* Remove default padding */
            font-size: 1.3rem; /* Adjust icon size */
            line-height: 1; /* Center icon */
            border-radius: 50% !important; /* Make them round */
        }
        /* Style for datalist suggestions (browser dependent) */
        #speciesSuggestions option {
            padding: 5px;
            font-size: 0.95rem;
        }

        /* --- Tables --- */
        /* ... (keep existing table styles) ... */

        /* --- Unified Modal Style --- */
        /* ... (keep existing modal styles) ... */

        /* --- Saved Scorecards Modal --- */
        #savedScorecardsModal .modal-body { padding: 0.5rem 0; } /* Reduce padding slightly */
        #savedScorecardsFilter {
            padding: 0.75rem 1.25rem;
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 0.5rem;
        }
        #savedScorecardsFilter .row > div { padding-top: 5px; padding-bottom: 5px; }
        #savedScorecardsListContainer {
             max-height: 60vh; /* Limit height and make scrollable */
             overflow-y: auto;
             padding: 0 1.25rem; /* Add padding back for the list */
        }
        /* ... (rest of saved scorecards styles are mostly fine, adjust lazy loading appearance if needed) ... */
        #savedScorecardsModal .scorecard-details {
            /* ... existing styles ... */
            /* Add a placeholder style for when details are loading */
            min-height: 100px; /* Prevent collapsing while loading */
            position: relative; /* For spinner positioning */
        }
        .details-loading-spinner {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
        }

        /* --- Notes Modal --- */
        /* ... (keep existing notes modal styles) ... */

        /* --- Camera Modal Styles --- */
        /* ... (keep existing camera modal styles) ... */

        /* --- Image Viewer Modal Styles --- */
        /* ... (keep existing image viewer modal styles) ... */
        #imageViewerModal .modal-body .spinner-border { margin-bottom: 1rem; } /* Style loading spinner */

        /* --- Toast Notification Styles --- */
        .toast-container {
            z-index: 1100; /* Above most elements */
            position: fixed;
            /* Position top-right or bottom-center as preferred */
            /* top: 20px; */
            /* right: 20px; */
             bottom: 20px;
             left: 50%;
             transform: translateX(-50%);
             width: auto; /* Allow container to size based on content */
             max-width: 90%; /* Prevent overly wide toasts */
        }
        .toast {
            font-size: 0.95rem; /* Adjust font size */
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15); /* Add shadow */
        }
        .toast-header .btn-close { margin-left: auto; } /* Ensure close button is right */

        /* --- Responsive Adjustments --- */
        /* ... (keep existing responsive styles, potentially adjust FAB position/size for small screens if needed) ... */
        @media (max-width: 767px) {
            /* ... existing ... */
            #fishingPage .row .btn#addFishBtn { display: none; } /* Hide original Add Fish button */
            .fab { bottom: 20px; right: 20px; width: 55px; height: 55px; font-size: 1.8rem; }
        }
        @media (max-width: 575px) {
            /* ... existing ... */
            .fab { bottom: 15px; right: 15px; width: 50px; height: 50px; font-size: 1.6rem; }
            .page-title-header { font-size: 1.2rem; margin-top: -5px; }
            .length-input-group .btn-length-adjust { width: 35px; height: 35px; font-size: 1.1rem; }
        }

    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container p-3">
        <!-- Toasts will be added here by JS -->
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Page Title Header (updated by JS) -->
        <h2 id="pageTitleHeader" class="page-title-header"></h2>

        <!-- Registration Page -->
        <div id="registrationPage" class="card-section page">
             <!-- Content unchanged -->
             <h2>Angler Registration</h2>
             <div class="mb-3"> <label for="anglerName" class="form-label">Angler Name</label> <input type="text" id="anglerName" class="form-control" placeholder="Enter your name"> </div>
             <div class="mb-3"> <label for="competitionDate" class="form-label">Date</label> <input type="date" id="competitionDate" class="form-control"> </div>
             <div class="mb-3"> <label for="venueInput" class="form-label">Venue</label> <input type="text" id="venueInput" class="form-control" placeholder="Enter venue"> </div>
             <div class="mb-3 form-check"> <input type="checkbox" class="form-check-input" id="isCompetition"> <label class="form-check-label" for="isCompetition">Competition</label> </div>
             <div class="mb-3">
                  <label for="zoneInput" class="form-label">Zone</label>
                  <select id="zoneInput" class="form-select" disabled> <option value="" selected>Select a zone</option> <option value="A">A</option> <option value="B">B</option> <option value="C">C</option> <option value="D">D</option> <option value="E">E</option> <option value="F">F</option> <option value="G">G</option> <option value="H">H</option> </select>
             </div>
             <div class="mb-3">
                 <label for="pegInput" class="form-label">Peg</label>
                 <select id="pegInput" class="form-select" disabled> <option value="" selected>Select a peg</option> <option value="1">1</option> <option value="2">2</option> <option value="3">3</option> <option value="4">4</option> <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option> <option value="9">9</option> <option value="10">10</option> <option value="11">11</option> <option value="12">12</option> <option value="13">13</option> <option value="14">14</option> <option value="15">15</option> <option value="16">16</option> <option value="17">17</option> <option value="18">18</option> <option value="19">19</option> <option value="20">20</option> <option value="21">21</option> <option value="22">22</option> <option value="23">23</option> <option value="24">24</option> <option value="25">25</option> </select>
             </div>
             <div class="button-group-center"> <button class="btn btn-primary" id="startRecordingBtn">Record Catch <i class="bi bi-arrow-right-circle ms-1"></i></button> </div>
        </div>

        <!-- Fishing Page -->
        <div id="fishingPage" class="card-section page">
            <h2>Record Your Catch</h2>
             <!-- Form Row -->
            <div class="row g-2 align-items-end"> <!-- Use g-2 gutters, align-items-end -->
                <div class="col-md-6 col-lg-4 mb-3">
                    <label for="speciesInput" class="form-label">Species</label>
                    <!-- Species Autocomplete -->
                    <input type="text" id="speciesInput" class="form-control" list="speciesSuggestions" placeholder="Type or select species">
                    <datalist id="speciesSuggestions">
                        <!-- Options populated by JS -->
                        <option value="Other (specify)">
                    </datalist>
                    <input type="text" id="customSpeciesInput" class="form-control mt-2" placeholder="Enter custom species name" style="display: none;">
                </div>
                <div class="col-sm-6 col-md-4 col-lg-3 mb-3"> <!-- Adjusted columns for +/- buttons -->
                     <label for="lengthInput" class="form-label">Length (cm)</label>
                     <!-- Length Input with +/- Buttons -->
                     <div class="length-input-group">
                         <button class="btn btn-secondary btn-length-adjust" id="lengthDecrementBtn" type="button" aria-label="Decrease length">-</button>
                         <input type="number" id="lengthInput" class="form-control" placeholder="Length" step="1" min="1" inputmode="numeric">
                         <button class="btn btn-secondary btn-length-adjust" id="lengthIncrementBtn" type="button" aria-label="Increase length">+</button>
                     </div>
                </div>
                <div id="initialsInputGroup" class="col-sm-6 col-md-3 col-lg-2 mb-3" style="display: none;">
                    <label for="initialsInput" class="form-label">Verifier Initials</label>
                    <input type="text" id="initialsInput" class="form-control" placeholder="Initials" maxlength="3" style="text-transform:uppercase">
                </div>
                <!-- Original Add Fish Button (Hidden on smaller screens by CSS, could be removed entirely if FAB is preferred) -->
                <div class="col-md-12 col-lg-3 mb-3 text-lg-end text-center mt-3 mt-lg-0 d-none d-lg-block">
                     <button class="btn btn-primary" id="addFishBtnDesktop"> <i class="bi bi-plus-circle me-1"></i> Add Fish </button>
                </div>
            </div>
            <!-- Back Button -->
            <div class="text-center mb-4 mt-2">
                 <button class="btn btn-secondary btn-sm" id="backFromFishingBtn"> <i class="bi bi-arrow-left-circle me-1"></i> Back to Registration </button>
            </div>

            <!-- Fish Log Table (keep structure, maybe add loading state) -->
            <h2 class="mt-4">Fish Log</h2>
            <div id="fishLogLoading" class="text-center p-3" style="display: none;">
                <div class="spinner-border text-secondary" role="status">
                    <span class="visually-hidden">Loading Log...</span>
                </div>
            </div>
            <div class="table-responsive">
                <table class="table table-striped table-hover">
                    <thead> <tr> <th class="photo-col">Photo</th> <th class="species-col">Species</th> <th class="length-col">Length</th> <th id="verifiedByHeader" class="verified-col" style="display:none;">Verified</th> <th class="delete-col">Del</th> </tr> </thead>
                    <tbody id="fishLog"></tbody>
                </table>
            </div>
            <!-- End Session Button Below Table -->
            <div class="button-group-center mt-4"> <button class="btn btn-success btn-lg" id="endSessionBtn"><i class="bi bi-check-circle me-1"></i> End & Save Session</button> </div>
        </div>

         <!-- Tally Page -->
         <div id="tallyPage" class="card-section page">
             <!-- Content unchanged, but ensure loading states are considered if population is slow -->
            <h2>Catch Summary</h2>
            <div class="catch-summary-details">
                <strong>Angler:</strong> <span id="summaryAngler"></span><br>
                <strong>Date:</strong> <span id="summaryDate"></span><br>
                <strong>Venue:</strong> <span id="summaryVenue"></span><br>
                <strong>Zone:</strong> <span id="summaryZone"></span><br>
                <strong>Peg:</strong> <span id="summaryPeg"></span><br>
                <span id="summaryVerifier"></span>
            </div>
            <div id="tallyLoading" class="text-center p-3" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Calculating Tally...</span>
                </div>
            </div>
            <div class="table-responsive">
                <table class="table">
                 <thead> <tr> <th>Species</th> <th>Total Caught</th> <th>Lengths (cm)</th> <th>Total Length (cm)</th> </tr> </thead>
                 <tbody id="tallyTable"></tbody>
                 <tfoot>
                    <tr> <td colspan="3" class="text-end"><strong>Total Length</strong></td> <td><strong id="tallyTotalLength">0 cm</strong></td> </tr>
                    <tr> <td colspan="3" class="text-end"><strong>Species Count</strong></td> <td><strong id="tallySpeciesCount">0</strong></td> </tr>
                    <tr> <td colspan="2" class="text-end"><strong>Longest Fish</strong></td> <td><strong id="longestFishSpecies">N/A</strong></td> <td><strong id="longestFishLength">0 cm</strong></td> </tr>
                    <tr> <td colspan="3" class="text-end"><strong>Points Total</strong></td> <td><strong id="tallyPointsTotal">0</strong></td> </tr>
                 </tfoot>
                </table>
            </div>
            <div class="button-group-center"> <button class="btn btn-secondary" id="backFromTallyBtn"><i class="bi bi-arrow-left-circle me-1"></i> Back to Log</button> </div>
        </div>
    </div> <!-- End of .container -->

    <!-- Splash Screen -->
    <!-- ... (keep existing splash screen HTML) ... -->

    <!-- Floating Action Button (FAB) - Placed outside container for fixed positioning -->
    <button class="fab hidden" id="addFishFab" aria-label="Add Fish">
        <i class="bi bi-plus-lg"></i>
    </button>

    <!-- Modals -->
    <!-- ... (Restore Session Modal - unchanged HTML) ... -->

    <div class="modal fade" id="savedScorecardsModal" tabindex="-1" aria-labelledby="savedScorecardsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="savedScorecardsModalLabel">Saved Scorecards</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Filter Section -->
                    <div id="savedScorecardsFilter">
                         <h6><i class="bi bi-filter me-1"></i>Filter Scorecards</h6>
                         <div class="row g-2 align-items-end">
                             <div class="col-md-4">
                                 <label for="filterAngler" class="form-label form-label-sm">Angler Name</label>
                                 <input type="text" id="filterAngler" class="form-control form-control-sm" placeholder="Any angler">
                             </div>
                             <div class="col-md-4">
                                 <label for="filterVenue" class="form-label form-label-sm">Venue</label>
                                 <input type="text" id="filterVenue" class="form-control form-control-sm" placeholder="Any venue">
                             </div>
                             <div class="col-md-4">
                                 <label for="filterDate" class="form-label form-label-sm">Date</label>
                                 <input type="date" id="filterDate" class="form-control form-control-sm">
                             </div>
                             <div class="col-12 text-end mt-2">
                                 <button class="btn btn-sm btn-outline-secondary" id="clearScorecardFilterBtn" type="button">Clear Filters</button>
                                 <button class="btn btn-sm btn-primary" id="applyScorecardFilterBtn" type="button"><i class="bi bi-funnel-fill me-1"></i>Apply</button>
                             </div>
                         </div>
                     </div>
                    <!-- List Container -->
                    <div id="savedScorecardsListContainer">
                        <div id="savedScorecardsList">
                            <!-- Initial Loading Spinner -->
                            <div class="text-center p-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div></div>
                        </div>
                    </div>
                    <!-- Toggle Older -->
                    <div id="olderScorecardsToggleContainer" class="text-center mt-3 p-3 border-top"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ... (End Session Modal - unchanged HTML) ... -->
    <!-- ... (Notes Modal - unchanged HTML) ... -->
    <!-- ... (MLS Info Modal - unchanged HTML) ... -->
    <!-- ... (Camera Modal - unchanged HTML) ... -->

    <div class="modal fade" id="imageViewerModal" tabindex="-1" aria-labelledby="imageViewerModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="imageViewerModalLabel">Fish Photo</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <!-- Loading Spinner for Image -->
                    <div id="imageViewerLoading" style="display: none;">
                         <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading image...</span>
                        </div>
                        <p class="mt-2">Loading image...</p>
                    </div>
                    <img id="fullImageView" src="#" alt="Full fish photo" style="display: none;"> <!-- Hide initially -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-info" id="shareImageBtn" disabled><i class="bi bi-share-fill me-1"></i> Share</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirm Photo Modal (REMOVED from initial add flow, could be repurposed later if needed) -->
    <!-- <div class="modal fade" id="confirmPhotoModal" ...> ... </div> -->

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Application JS (WITH UPGRADES) -->
    <script>
        // --- Global Variables ---
        const fishCategories = { /* ... Keep existing categories ... */
            "Flatfish": [ "Brill", "Dab", "Flounder", "Halibut", "Megrim", "Plaice", "Sole (Dover)", "Sole (Lemon)", "Turbot" ],
             "Round Fish": [ "Bass", "Bream (Black)", "Bream (Gilthead)", "Bream (Red)", "Bream (Sea)", "Bull Huss", "Coalfish", "Cod", "Conger Eel", "Dogfish", "Dogfish (Black Mouth)", "Gurnard (Red)", "Gurnard (Tub)", "Haddock", "Hake", "John Dory", "Ling", "Mackerel", "Monkfish", "Mullet (Grey)", "Mullet (Red)", "Pollack", "Poor Cod", "Pouting", "Saithe", "Triggerfish", "Whiting" ],
             "Rays and Skates": [ "Ray (Blonde)", "Ray (Small-eyed)", "Ray (Starry)", "Ray (Thornback)", "Skate" ],
             "Sharks": [ "Shark (Blue)", "Shark (Porbeagle)", "Shark (Thresher)", "Smoothhound", "Smoothhound (Starry)", "Spurdog", "Tope" ],
             "Wrasse": [ "Wrasse (Ballan)", "Wrasse (Cuckoo)" ]
        };
        let fishData = [];
        let currentAngler = null;
        let currentDate = null;
        let currentVenue = null;
        let currentZone = null;
        let currentPeg = null;
        let currentPage = 'splashScreen';
        let isAppActive = false;
        let historyHijacked = false; // Keep track if we've pushed our state
        let notesModalInstance = null;
        let cameraModalInstance = null;
        let imageViewerModalInstance = null;
        // let confirmPhotoModalInstance = null; // Removed from initial flow
        let db = null;
        let currentStream = null;
        let currentFishIdForPhoto = null;
        let currentImageBlobForViewer = null;
        let currentImageIdForViewer = null;
        let isDropdownPopulated = false;
        // let pendingFishData = null; // Removed, handled differently now
        let currentScorecardFilter = { angler: '', venue: '', date: '' }; // For scorecard filtering

        // --- Constants ---
        const DB_NAME = 'SeaCatchDB';
        const DB_VERSION = 1;
        const IMAGE_STORE_NAME = 'fishImages';
        const POINTS_PER_SPECIES = 10;
        const SCORECARD_DISPLAY_LIMIT = 5; // For lazy loading older scorecards

        // --- Utility Functions ---
        function formatDate(dateString) { /* ... No changes needed ... */ if (!dateString) return 'N/A'; try { const d = new Date(dateString + 'T00:00:00Z'); return isNaN(d.getTime()) ? dateString : d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric', timeZone: 'UTC' }); } catch (e) { console.error("Date format err:", e); return dateString; } }
        function formatDateForInput(date) { /* ... No changes needed ... */ const d = new Date(date); const year = d.getFullYear(); const month = (d.getMonth() + 1).toString().padStart(2, '0'); const day = d.getDate().toString().padStart(2, '0'); return `${year}-${month}-${day}`; }
        function generateUUID() { /* ... No changes needed ... */ return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16) ); }

        // Toast Notification Function
        function showToast(message, type = 'success', delay = 5000) {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) {
                console.error("Toast container not found!");
                alert(message); // Fallback to alert
                return;
            }

            const toastId = `toast-${Date.now()}`;
            const bgClass = type === 'danger' ? 'bg-danger' : (type === 'warning' ? 'bg-warning text-dark' : 'bg-success');
            const textClass = (type === 'warning') ? '' : 'text-white'; // Dark text for warning bg

            const toastHtml = `
                <div id="${toastId}" class="toast align-items-center ${textClass} ${bgClass} border-0" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="${delay}">
                  <div class="d-flex">
                    <div class="toast-body">
                      ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                  </div>
                </div>`;

            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            const toastElement = document.getElementById(toastId);
            const toastInstance = new bootstrap.Toast(toastElement, { autohide: true, delay: delay });

            // Ensure it's removed from DOM after hiding
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });

            toastInstance.show();
            console.log(`Toast shown: ${message} (Type: ${type})`);
        }


        // --- IndexedDB Functions ---
        // (No changes needed, assume functional unless console shows DB errors)
        function initDb() { return new Promise((resolve, reject) => { if (db) { resolve(db); return; } console.log("Initializing IndexedDB..."); const request = indexedDB.open(DB_NAME, DB_VERSION); request.onerror = (event) => { console.error("IndexedDB error:", event.target.error); reject("IndexedDB error: " + event.target.error); }; request.onsuccess = (event) => { db = event.target.result; console.log("IndexedDB initialized successfully."); resolve(db); }; request.onupgradeneeded = (event) => { console.log("Upgrading IndexedDB..."); db = event.target.result; if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) { console.log(`Creating object store: ${IMAGE_STORE_NAME}`); db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' }); } }; }); }
        function saveImageToDb(imageId, blob) { return new Promise(async (resolve, reject) => { if (!db) { try { await initDb(); } catch(dbErr) { reject("Failed to init DB for saving image: " + dbErr); return; } } if (!blob || !imageId) { reject("Missing imageId or blob data."); return; } const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IMAGE_STORE_NAME); const imageData = { id: imageId, blob: blob }; console.log(`Attempting to save image with ID: ${imageId}`); const request = store.put(imageData); request.onsuccess = () => { console.log(`Image ${imageId} saved to IndexedDB.`); resolve(); }; request.onerror = (event) => { console.error(`Error saving image ${imageId}:`, event.target.error); reject(event.target.error); }; transaction.oncomplete = () => { console.log("Save image transaction completed."); }; transaction.onerror = (event) => { console.error("Save image transaction error:", event.target.error); reject("Save image transaction failed."); }; }); }
        function getImageFromDb(imageId) { return new Promise(async (resolve, reject) => { if (!db) { try { await initDb(); } catch(dbErr) { reject("Failed to init DB for getting image: " + dbErr); return; } } if (!imageId) { reject("Missing imageId."); return; } const transaction = db.transaction([IMAGE_STORE_NAME], 'readonly'); const store = transaction.objectStore(IMAGE_STORE_NAME); const request = store.get(imageId); request.onsuccess = (event) => { if (event.target.result) { console.log(`Image ${imageId} retrieved from IndexedDB.`); resolve(event.target.result.blob); } else { console.log(`Image ${imageId} not found in IndexedDB.`); resolve(null); } }; request.onerror = (event) => { console.error(`Error retrieving image ${imageId}:`, event.target.error); reject(event.target.error); }; }); }
        function deleteImageFromDb(imageId) { return new Promise(async (resolve, reject) => { if (!db) { try { await initDb(); } catch(dbErr) { reject("Failed to init DB for deleting image: " + dbErr); return; } } if (!imageId) { resolve(); return; } const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IMAGE_STORE_NAME); console.log(`Attempting to delete image with ID: ${imageId}`); const request = store.delete(imageId); request.onsuccess = () => { console.log(`Image ${imageId} deleted from IndexedDB.`); resolve(); }; request.onerror = (event) => { console.error(`Error deleting image ${imageId}:`, event.target.error); reject(event.target.error); }; transaction.oncomplete = () => { console.log("Delete image transaction completed."); }; transaction.onerror = (event) => { console.error("Delete image transaction error:", event.target.error); reject("Delete image transaction failed."); }; }); }

        // --- Page/State Management & Navigation ---
        function showPage(pageId) {
            console.log(`DEBUG: showPage called for: ${pageId}`);
            const pageTitleHeader = document.getElementById('pageTitleHeader');
            const fab = document.getElementById('addFishFab');

            document.querySelectorAll('.page').forEach(p => { p.style.display = 'none'; });

            const target = document.getElementById(pageId);
            if (target) {
                const displayStyle = pageId === 'splashScreen' ? 'flex' : 'block';
                target.style.display = displayStyle;
                currentPage = pageId;

                // Update page title header
                if (pageTitleHeader) {
                    let title = '';
                    switch (pageId) {
                        case 'registrationPage': title = 'Session Setup'; break;
                        case 'fishingPage': title = 'Catch Log'; break;
                        case 'tallyPage': title = 'Session Summary'; break;
                        default: title = 'Sea Catch Scorer'; // Default or Splash
                    }
                    pageTitleHeader.textContent = title;
                    pageTitleHeader.style.display = (pageId !== 'splashScreen') ? 'block' : 'none';
                }

                 // Show/Hide FAB
                 if (fab) {
                     fab.classList.toggle('hidden', pageId !== 'fishingPage');
                 }

                const container = document.querySelector('.container');
                if(container) {
                    container.style.display = (pageId === 'splashScreen') ? 'none' : 'block';
                }

                if(pageId !== 'splashScreen' && !isAppActive) {
                    activateAppMode();
                }

                // Push state for non-splash pages to enable back button navigation *within* the app
                if (pageId !== 'splashScreen' && (!history.state || history.state.page !== pageId)) {
                     try {
                         // Only push if the state doesn't already represent the current page
                         history.pushState({ page: pageId }, `Page ${pageId}`, `#${pageId}`);
                         historyHijacked = true; // Indicate we've pushed a state
                         console.log(`DEBUG: Pushed history state for ${pageId}`);
                     } catch (e) {
                         console.error("Error pushing history state:", e);
                         historyHijacked = false;
                     }
                }

                if (pageId !== 'splashScreen') {
                    saveTempSession(); // Save state when moving to non-splash page
                }

                // Trigger specific updates when page becomes visible
                 if (pageId === 'fishingPage') {
                     updateFishLog(); // Refresh log view
                 } else if (pageId === 'tallyPage') {
                     showLoading('tallyLoading', true);
                     setTimeout(() => { // Simulate calculation time / allow UI update
                         populateTallySummaryFields();
                         populateTallyTable();
                         showLoading('tallyLoading', false);
                     }, 50); // Small delay
                 }

            } else {
                console.error(`ERROR: Page element not found for ID: ${pageId}. Defaulting to splash screen.`);
                const splash = document.getElementById('splashScreen');
                const container = document.querySelector('.container');
                if(splash) splash.style.display = 'flex';
                if(container) container.style.display = 'none';
                if (pageTitleHeader) pageTitleHeader.style.display = 'none';
                if (fab) fab.classList.add('hidden');
                currentPage = 'splashScreen';
                deactivateAppMode(); // Ensure deactivated if falling back
            }
        }

        function activateAppMode() {
            if (!isAppActive) {
                console.log("Activating App Mode");
                isAppActive = true;
                // History state is now pushed in showPage
            }
        }

        function deactivateAppMode() {
            if (isAppActive) {
                console.log("Deactivating App Mode.");
                isAppActive = false;
                historyHijacked = false;
                // We might want to clear history related to the app here if possible,
                // but standard history API doesn't allow selective removal easily.
                // Going back to splash usually means session ended or started fresh.
            }
        }

        // --- History/Navigation Control (Revised) ---
        function handleBackButton(event) {
             console.log("DEBUG: popstate event detected.", "Current Page:", currentPage, "History State:", event.state);

             if (isAppActive && historyHijacked) {
                 const targetPage = event.state ? event.state.page : null;
                 console.log(`DEBUG: App Active & Hijacked. Target page from state: ${targetPage}`);

                 // If the state is null or undefined, it might mean we're going back *before* our first pushState
                 // or the user used browser tools to manipulate history. Let's go to splash.
                 if (!targetPage) {
                     console.log("DEBUG: No valid state found, going to splash.");
                     showPage('splashScreen');
                     // Don't push state here, let showPage handle it if needed
                     return;
                 }

                 // If the state matches the current page, it might be an initial load or refresh state push.
                 // Or, if we are on splash, allow default back behavior (exit PWA/go back browser history).
                 if (targetPage === currentPage || currentPage === 'splashScreen') {
                      console.log("DEBUG: State matches current page or on splash, allowing default back.");
                      // Potentially deactivate app mode if we are navigating away from the app pages entirely
                      if (currentPage === 'splashScreen') {
                         deactivateAppMode();
                      }
                      // Allow default browser behavior ONLY if not actively managed by app state
                      // This part is tricky. If the user hits back multiple times fast, states might get confusing.
                      // For simplicity now, if state exists, we handle it via showPage.
                 }

                 // Navigate to the page indicated by the history state
                 console.log(`DEBUG: Navigating via history state to: ${targetPage}`);
                 showPage(targetPage);

             } else {
                 console.log("DEBUG: App not active or history not hijacked, allowing default back behavior.");
                 // Allow default browser back behavior
             }
        }

        function handleBeforeUnload(event) {
            if (isAppActive && fishData.length > 0) {
                console.log("beforeunload prompt triggered due to active session with data.");
                event.preventDefault();
                event.returnValue = 'You have an unsaved fishing session. Are you sure you want to leave?';
                return event.returnValue;
            } else {
                console.log("beforeunload allowed (No active session or no data).");
            }
        }

        // --- Session Management ---
        function saveTempSession() { /* ... No change needed, but ensure it saves currentPage correctly ... */ if (!isAppActive && currentPage !== 'splashScreen') { console.warn("Attempted to save temp session while app not active and not on splash."); return; } const temp = { fishData: fishData||[], currentAngler, currentDate, currentVenue, currentZone, currentPeg, currentPage, isAppActive, historyHijacked: historyHijacked, isCompetition: !!(currentZone && currentPeg) }; try { localStorage.setItem('temp_session', JSON.stringify(temp)); console.log("Temp session saved for page:", currentPage); } catch (e) { console.error("Save temp session error:", e); if(e.name === 'QuotaExceededError'){ showToast("Warning: Could not save session progress, local storage might be full. Please clear old scorecards if possible.", 'danger');}} }
        function clearTempSession() { /* ... No change needed ... */ try { localStorage.removeItem('temp_session'); console.log("Temporary session cleared."); } catch (e) { console.error("Clear temp session error:", e); } }
        function checkRestoreSession() { /* ... Logic mostly unchanged, but uses showPage at the end ... */ console.log("DEBUG: checkRestoreSession started."); let data; try { const temp = localStorage.getItem('temp_session'); if (!temp) { console.log("DEBUG: No temp session found in localStorage."); setTodaysDate(); showPage('splashScreen'); return; } console.log("DEBUG: Found temp session string:", temp.substring(0, 100) + "..."); data = JSON.parse(temp); if (!data || !Array.isArray(data.fishData)) throw new Error("Invalid temp session format."); } catch (e) { console.error("Error reading temp session:", e); clearTempSession(); setTodaysDate(); showPage('splashScreen'); return; } if (data.currentAngler || data.currentDate || data.currentVenue || data.fishData.length > 0) { console.log("DEBUG: Found restorable session content, showing modal."); document.getElementById('restoreAngler').textContent=data.currentAngler||'N/A'; document.getElementById('restoreDate').textContent=data.currentDate?formatDate(data.currentDate):'N/A'; document.getElementById('restoreFishCount').textContent=data.fishData.length; const modalEl=document.getElementById('restoreSessionModal'); if(modalEl){ try { let mI=bootstrap.Modal.getInstance(modalEl); if(!mI) mI=new bootstrap.Modal(modalEl,{backdrop:'static',keyboard:false}); console.log("DEBUG: Showing restoreSessionModal."); mI.show(); } catch (modalError) { console.error("Error showing restore modal:", modalError); clearTempSession(); setTodaysDate(); showPage('splashScreen'); } } else { console.error("ERROR: Restore modal element not found."); clearTempSession(); setTodaysDate(); showPage('splashScreen'); } } else { console.log("DEBUG: Temp session found but contained no relevant data, clearing and showing splash."); clearTempSession(); setTodaysDate(); showPage('splashScreen'); } }
        function restoreSession() { /* ... Logic mostly unchanged, but uses showPage and updates historyHijacked ... */ console.log("DEBUG: restoreSession() triggered."); let temp; try { const sS=localStorage.getItem('temp_session'); if(!sS)throw new Error("No temp session data found in storage."); temp=JSON.parse(sS); if(!temp||!Array.isArray(temp.fishData))throw new Error("Invalid temp session data format."); } catch(e){ console.error("Error restoring session data:",e); showToast("Failed to restore session data. Starting fresh.", 'danger'); startNewSession(); return; } fishData=temp.fishData||[]; currentAngler=temp.currentAngler||null; currentDate=temp.currentDate||null; currentVenue=temp.currentVenue||null; currentZone=temp.currentZone||null; currentPeg=temp.currentPeg||null; const page=temp.currentPage||'registrationPage'; isAppActive=temp.isAppActive||false; historyHijacked=temp.historyHijacked||false; // Restore history state marker
        const restoredIsCompetition = temp.isCompetition === true; console.log("DEBUG: Restoring state:",{currentAngler, currentDate, currentVenue, currentZone, currentPeg, page, isAppActive, historyHijacked, isCompetition: restoredIsCompetition}); try{ if(currentAngler)document.getElementById('anglerName').value=currentAngler; if(currentDate)document.getElementById('competitionDate').value=currentDate; if(currentVenue)document.getElementById('venueInput').value=currentVenue; document.getElementById('isCompetition').checked=restoredIsCompetition; toggleCompetitionFields(false); if(currentZone)document.getElementById('zoneInput').value=currentZone; if(currentPeg)document.getElementById('pegInput').value=currentPeg; } catch(e) { console.error("Error restoring registration fields:",e); } populateSpeciesDropdown(); // Ensure dropdown is ready
        // updateFishLog/populateTally called by showPage
        hideModal('restoreSessionModal');
        showPage(page); // This will handle activating app mode and pushing history if needed
        console.log("DEBUG: Session restoration complete."); }
        function startNewSession() { /* ... Logic unchanged, uses showPage ... */ console.log("DEBUG: startNewSession() triggered."); clearTempSession(); resetApp(); hideModal('restoreSessionModal'); showPage('splashScreen'); }

        // --- UI Interaction & Fish Adding ---
        function showLoading(elementId, show = true) {
             const el = document.getElementById(elementId);
             if (el) {
                 el.style.display = show ? 'block' : 'none';
             }
        }

        // Populate Species Datalist (Changed from Dropdown)
        function populateSpeciesDropdown() {
            if (isDropdownPopulated) { return; }
            console.log("Populating species datalist...");
            const datalist = document.getElementById('speciesSuggestions');
            if (!datalist) { console.error("Species datalist (#speciesSuggestions) missing!"); return; }
            try {
                const allSpecies = [];
                Object.values(fishCategories).forEach(list => allSpecies.push(...list));
                allSpecies.sort();

                // Clear existing options except 'Other'
                const existingOptions = datalist.querySelectorAll('option:not([value="Other (specify)"])');
                existingOptions.forEach(opt => opt.remove());

                allSpecies.forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s;
                    // Optionally add text content if different from value: opt.textContent = s;
                    datalist.appendChild(opt);
                });

                isDropdownPopulated = true;
                console.log("Species datalist populated successfully.");
            } catch (error) {
                console.error("Error during species datalist population:", error);
                // Maybe add a disabled input state?
            }
        }

        function toggleCustomSpeciesInput() {
            const sel = document.getElementById('speciesInput'), custom = document.getElementById('customSpeciesInput');
            if (!sel || !custom) return;
            const showCustom = sel.value === 'Other (specify)';
            custom.style.display = showCustom ? 'block' : 'none';
            if (showCustom) {
                custom.focus(); // Focus custom input if shown
            } else {
                custom.value = '';
                 // If switching away from Other, focus Length input next
                 document.getElementById('lengthInput')?.focus();
            }
        }

        // Focus next input after selecting a *standard* species
        function handleSpeciesSelection() {
            const speciesInput = document.getElementById('speciesInput');
            const customSpeciesInput = document.getElementById('customSpeciesInput');
            const lengthInput = document.getElementById('lengthInput');

            toggleCustomSpeciesInput(); // Handle 'Other' visibility

            // If a valid, non-'Other' species is selected/entered from datalist, focus length
            const selectedValue = speciesInput.value;
            const isValidSpecies = Array.from(document.querySelectorAll('#speciesSuggestions option'))
                                       .some(option => option.value === selectedValue && selectedValue !== 'Other (specify)');

            if (isValidSpecies && lengthInput) {
                lengthInput.focus();
            }
            // If 'Other' is selected, focus is handled by toggleCustomSpeciesInput
        }

        // Handle +/- Length Buttons
        function adjustLength(amount) {
            const lengthInput = document.getElementById('lengthInput');
            if (lengthInput) {
                let currentValue = parseInt(lengthInput.value, 10);
                if (isNaN(currentValue)) {
                    currentValue = 0; // Start from 0 if empty or invalid
                }
                let newValue = Math.max(1, currentValue + amount); // Ensure minimum length is 1
                 // Add a reasonable max if desired, e.g., newValue = Math.min(500, newValue);
                lengthInput.value = newValue;
                // Trigger input event if needed by other logic, though direct setting usually suffices
                // lengthInput.dispatchEvent(new Event('input'));
            }
        }

        function toggleCompetitionFields(updateLog = true) { /* ... Logic mostly unchanged ... */ try{ const isChecked = document.getElementById('isCompetition').checked; const zone=document.getElementById('zoneInput'); const peg=document.getElementById('pegInput'); const initialsGroup = document.getElementById('initialsInputGroup'); const verifiedByHeader = document.getElementById('verifiedByHeader'); if (zone) zone.disabled=!isChecked; if (peg) peg.disabled=!isChecked; if (initialsGroup) initialsGroup.style.display = isChecked ? 'block' : 'none'; if (verifiedByHeader) verifiedByHeader.style.display = isCompetition ? 'table-cell' : 'none'; if (!isChecked) { if (zone) zone.value = ''; if (peg) peg.value = ''; const initialsInput = document.getElementById('initialsInput'); if (initialsInput) initialsInput.value = ''; fishData.forEach(fish => fish.initials = null); currentZone = null; currentPeg = null; } if (updateLog && currentPage === 'fishingPage') { updateFishLog(); } } catch(e){console.error("Toggle competition fields error:",e);} }
        function setTodaysDate() { /* ... No changes needed ... */ try { const dateInput = document.getElementById('competitionDate'); if (dateInput && !dateInput.value) { const today = new Date(); const formattedDate = formatDateForInput(today); dateInput.value = formattedDate; console.log("DEBUG: Set date input to today:", formattedDate); } } catch (e) { console.error("Error setting today's date:", e); } }

        function startApp() { /* ... Calls showPage ... */
            console.log("DEBUG: startApp() triggered.");
            setTodaysDate();
            populateSpeciesDropdown(); // Ensure species are ready
            showPage('registrationPage');
        }

        function startRecording() { /* ... Validation logic unchanged, uses showPage ... */
            console.log("DEBUG: startRecording() triggered."); // DEBUG
            const nameEl=document.getElementById('anglerName'), dateEl=document.getElementById('competitionDate'), venueEl=document.getElementById('venueInput'), checkEl=document.getElementById('isCompetition'), zoneEl=document.getElementById('zoneInput'), pegEl=document.getElementById('pegInput');
            let isValid = true; let errorMsg = "";
            if(!nameEl || !dateEl || !venueEl || !checkEl || !zoneEl || !pegEl){ showToast("Critical error: Form elements are missing.", 'danger'); return; }
            // Clear previous invalid states
            [nameEl, dateEl, venueEl, zoneEl, pegEl].forEach(el => el?.classList.remove('is-invalid'));
            const name=nameEl.value.trim(); const date=dateEl.value; const venue=venueEl.value.trim(); const isComp=checkEl.checked; const zone=zoneEl.value; const peg=pegEl.value;
            // Validation logic... (unchanged)
            if(!name){ errorMsg += "Angler Name is required.\n"; isValid = false; nameEl.classList.add('is-invalid'); } else { nameEl.classList.remove('is-invalid'); } if(!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)){ errorMsg += "A valid Date is required.\n"; isValid = false; dateEl.classList.add('is-invalid'); } else { dateEl.classList.remove('is-invalid'); } if(!venue){ errorMsg += "Venue is required.\n"; isValid = false; venueEl.classList.add('is-invalid'); } else { venueEl.classList.remove('is-invalid'); } if(isComp){ if(!zone){ errorMsg += "Zone is required for competition.\n"; isValid = false; zoneEl.classList.add('is-invalid'); } else { zoneEl.classList.remove('is-invalid'); } if(!peg){ errorMsg += "Peg is required for competition.\n"; isValid = false; pegEl.classList.add('is-invalid'); } else { pegEl.classList.remove('is-invalid'); } } else { zoneEl.classList.remove('is-invalid'); pegEl.classList.remove('is-invalid'); }
            if (!isValid) { showToast("Please fix the errors:\n" + errorMsg.replace(/\n/g, '<br>'), 'warning', 7000); return; }
            // Set globals and proceed
            currentAngler=name; currentDate=date; currentVenue=venue; currentZone=isComp?zone:null; currentPeg=isComp?peg:null; const isActuallyCompetition = !!(currentZone && currentPeg);
            console.log("DEBUG: Starting recording session:",{currentAngler,currentDate,currentVenue,currentZone,currentPeg,isCompetition:isActuallyCompetition});
            // populateSpeciesDropdown(); // Already called in startApp or restoreSession
            // activateAppMode(); // Handled by showPage
            // saveTempSession(); // Handled by showPage
            // updateFishLog(); // Handled by showPage
            showPage('fishingPage');
            if (isActuallyCompetition) {
                 showModal('mlsInfoModal'); // Keep MLS info modal for competitions
            }
        }

        // Add Fish - Revised Workflow (No Confirmation Modal)
        async function addFish() {
            console.log("DEBUG: addFish() triggered.");
            const spInput = document.getElementById('speciesInput');
            const custEl = document.getElementById('customSpeciesInput');
            const lenEl = document.getElementById('lengthInput');
            const initialsEl = document.getElementById('initialsInput');
            const isCompetition = document.getElementById('isCompetition').checked;

            let isValid = true;
            let errorMsg = "";
            [spInput, custEl, lenEl, initialsEl].forEach(el => el?.classList.remove('is-invalid'));

            if (!spInput || !custEl || !lenEl) {
                showToast("Critical error: Add fish form elements missing.", 'danger');
                return;
            }

            let species = spInput.value.trim();
            const lenVal = lenEl.value.trim();
            let length;
            let initials = null;

            // Validation
            if (!lenVal || isNaN(parseFloat(lenVal)) || parseFloat(lenVal) <= 0 || parseFloat(lenVal) > 500) {
                errorMsg += "Valid length (1-500cm) required.\n";
                isValid = false; lenEl.classList.add('is-invalid');
            } else {
                length = Math.round(parseFloat(lenVal));
            }

            if (species === 'Other (specify)') {
                species = custEl.value.trim();
                if (!species) {
                    errorMsg += "Custom species name required when 'Other' is selected.\n";
                    isValid = false; custEl.classList.add('is-invalid');
                } else if (!/^[a-zA-Z0-9\s'-]+$/.test(species)) {
                    errorMsg += "Invalid characters in custom species name.\n";
                    isValid = false; custEl.classList.add('is-invalid');
                }
            } else if (!species) {
                errorMsg += "Please select or enter a species.\n";
                isValid = false; spInput.classList.add('is-invalid');
            }
             // Add check if entered species is not in datalist and not 'Other'? Optional.

            if (isCompetition && initialsEl) {
                initials = initialsEl.value.trim().toUpperCase();
                if (!initials) {
                    errorMsg += "Verifier initials are required for competition entries.\n";
                    isValid = false; initialsEl.classList.add('is-invalid');
                } else if (initials.length < 2) {
                    errorMsg += "Please enter at least 2 initials for the verifier.\n";
                    isValid = false; initialsEl.classList.add('is-invalid');
                }
            }

            if (!isValid) {
                showToast("Please fix the errors:<br>" + errorMsg.replace(/\n/g, '<br>'), 'warning', 7000);
                // Focus the first invalid field
                const firstInvalid = document.querySelector('.is-invalid');
                firstInvalid?.focus();
                return;
            }

            // Data is valid, create fish object
            const fishId = generateUUID();
            const newFish = { id: fishId, species, length, initials: initials || null, imageId: null };

            console.log("DEBUG: Fish data validated:", newFish);

            // --- New Photo Workflow ---
            // Try to open camera immediately instead of asking
            try {
                // Check for camera capabilities roughly
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    console.log("DEBUG: Attempting to open camera immediately.");
                    // Pass the fish data along so it can be added after photo attempt
                    openCamera(fishId, newFish);
                } else {
                    console.log("DEBUG: Camera not available, adding fish without photo prompt.");
                    finalizeAddFish(newFish); // Add fish directly if no camera
                }
            } catch (err) {
                console.error("Error checking/accessing camera:", err);
                showToast("Could not access camera, adding fish without photo.", "warning");
                finalizeAddFish(newFish); // Add fish if camera check fails
            }
        }

        // Helper function to actually add fish data and update UI
        function finalizeAddFish(fishObject) {
             if (!fishObject) {
                 console.error("FinalizeAddFish called with null fish object!");
                 return;
             }
            fishData.push(fishObject);
            console.log("Added fish to main data:", fishObject);

            // Reset form
            try {
                document.getElementById('speciesInput').value = '';
                document.getElementById('customSpeciesInput').value = '';
                document.getElementById('customSpeciesInput').style.display = 'none';
                document.getElementById('lengthInput').value = '';
                const initialsInput = document.getElementById('initialsInput');
                if (initialsInput) initialsInput.value = '';
                ['speciesInput', 'customSpeciesInput', 'lengthInput', 'initialsInput'].forEach(id => document.getElementById(id)?.classList.remove('is-invalid'));

                // Refocus species input for next entry
                document.getElementById('speciesInput').focus();
            } catch (e) {
                console.error("Error resetting form fields after add:", e);
            }

            updateFishLog(); // Update the table
            saveTempSession(); // Save progress
             showToast(`${fishObject.species} (${fishObject.length}cm) added to log.`, 'success', 3000);
        }


        async function updateFishLog() { /* ... Logic mostly unchanged, but uses loading state ... */
             const logBody = document.getElementById('fishLog');
             const isCompetition = document.getElementById('isCompetition').checked;
             const verifiedByHeader = document.getElementById('verifiedByHeader');

             if (!logBody) { console.error("Fish log body (#fishLog) not found!"); return; }

             showLoading('fishLogLoading', true); // Show loading spinner
             logBody.innerHTML = ''; // Clear previous entries

             if (verifiedByHeader) { verifiedByHeader.style.display = isCompetition ? 'table-cell' : 'none'; }

             const colCount = 3 + (isCompetition ? 1 : 0) + 1;
             if (fishData.length === 0) {
                 const row = logBody.insertRow();
                 const cell = row.insertCell();
                 cell.colSpan = colCount;
                 cell.className = 'text-center text-muted p-4';
                 cell.textContent = 'No fish added yet. Use the (+) button to record catches.';
                 showLoading('fishLogLoading', false); // Hide loading
                 return;
             }

             // Use Promise.allSettled to load all thumbnails concurrently
            const rowPromises = fishData.map(async (f, index) => {
                 const rowIndex = fishData.length - 1 - index; // Display newest first
                 const fish = fishData[rowIndex];
                 const row = document.createElement('tr'); // Create row element

                 const photoCell = row.insertCell();
                 photoCell.className = 'photo-col';
                 const thumbContainer = document.createElement('span');
                 thumbContainer.className = 'thumbnail-container';
                 thumbContainer.id = `thumb-container-${fish.id}`;
                 thumbContainer.innerHTML = '<i class="bi bi-camera no-photo-icon"></i>';
                 thumbContainer.title = fish.imageId ? "Click to view photo" : "Click to add photo";
                 thumbContainer.onclick = () => {
                     const currentFish = fishData.find(f_inner => f_inner.id === fish.id);
                     if (currentFish?.imageId) {
                         showFullscreenImage(currentFish.imageId);
                     } else {
                         // Open camera, pass the fish object for potential future use if needed
                         openCamera(fish.id, fish);
                     }
                 };
                 photoCell.appendChild(thumbContainer);

                 row.insertCell().textContent = fish.species || '?';
                 const lenCell = row.insertCell();
                 lenCell.className = 'length-col';
                 lenCell.textContent = fish.length ? `${fish.length} cm` : '?';
                 if (isCompetition) {
                     const initialsCell = row.insertCell();
                     initialsCell.className = 'verified-col';
                     initialsCell.textContent = fish.initials || '-';
                 }
                 const deleteCell = row.insertCell();
                 deleteCell.className = 'delete-col';
                 const deleteBtn = document.createElement('button');
                 deleteBtn.type = 'button';
                 deleteBtn.className = 'delete-icon-btn';
                 deleteBtn.title = 'Delete this fish';
                 deleteBtn.setAttribute('aria-label', `Delete ${fish.species || 'fish'} (${fish.length || '?'}cm)`);
                 deleteBtn.innerHTML = '<i class="bi bi-x-circle-fill" aria-hidden="true"></i>';
                 deleteBtn.addEventListener('click', (e) => {
                     e.stopPropagation();
                     const currentIndex = fishData.findIndex(f_inner => f_inner.id === fish.id);
                     if (currentIndex !== -1) {
                         deleteFish(currentIndex);
                     } else {
                         console.error("Could not find fish to delete by ID:", fish.id);
                         showToast("Error: Could not delete fish, ID not found.", 'danger');
                     }
                 });
                 deleteCell.appendChild(deleteBtn);

                 // Return the created row and a promise for its thumbnail loading
                 return {
                     row,
                     thumbnailPromise: fish.imageId ? loadThumbnail(fish.id, fish.imageId) : Promise.resolve()
                 };
            });

             const results = await Promise.allSettled(rowPromises);

             // Append rows in the correct order (newest first)
             results.reverse().forEach(result => {
                 if (result.status === 'fulfilled' && result.value.row) {
                     logBody.appendChild(result.value.row);
                 } else if (result.status === 'rejected') {
                     console.error("Failed to create fish log row:", result.reason);
                 }
             });

             // Wait for all thumbnail promises (best effort, don't block UI for long)
            // This part is tricky, as we don't want to wait indefinitely.
            // The loadThumbnail function itself updates the container.
            // We can just let them load asynchronously.

             showLoading('fishLogLoading', false); // Hide loading spinner
        }

        async function loadThumbnail(fishId, imageId) { /* ... Logic unchanged, still updates container directly ... */ const container = document.getElementById(`thumb-container-${fishId}`); if (!container || !imageId) return; container.innerHTML = '<div class="spinner-border spinner-border-sm text-secondary" role="status"><span class="visually-hidden">Loading...</span></div>'; container.onclick = null; try { const blob = await getImageFromDb(imageId); if (blob) { const url = URL.createObjectURL(blob); container.innerHTML = `<img src="${url}" alt="Fish thumbnail" class="fish-thumbnail">`; container.title = "Click to view full size"; container.onclick = () => { const currentFish = fishData.find(fish => fish.id === fishId); if (currentFish?.imageId) { showFullscreenImage(currentFish.imageId); } }; // Revoke URL when no longer needed? Complex for multiple thumbs. Rely on browser cache / GC.
         } else { container.innerHTML = `<i class="bi bi-image-alt no-photo-icon" title="Image data missing"></i>`; container.title = "Click to add photo"; container.onclick = () => { openCamera(fishId); }; } } catch (error) { console.error(`Error loading thumbnail for ${imageId}:`, error); container.innerHTML = `<i class="bi bi-exclamation-triangle-fill text-danger no-photo-icon" title="Error loading image"></i>`; container.title = "Error loading image"; container.onclick = null; } }
        async function deleteFish(idx) { /* ... Uses showToast instead of alert ... */ if (idx >= 0 && idx < fishData.length) { const fishToDelete = fishData[idx]; const { id, species, length, imageId } = fishToDelete; let confirmMessage = `Delete ${species || '?'} (${length || '?'}cm)?`; if (imageId) { confirmMessage += " The photo will also be permanently deleted."; } if (confirm(confirmMessage)) { console.log("Deleting fish index:", idx, "ID:", id, "ImageID:", imageId); try { if (imageId) { await deleteImageFromDb(imageId); } fishData.splice(idx, 1); updateFishLog(); saveTempSession(); showToast("Fish deleted successfully.", 'info'); } catch (error) { console.error("Error during fish/image deletion:", error); showToast("An error occurred while deleting the fish or its photo.", 'danger'); updateFishLog(); // Refresh log even on error
                 } } else { console.log("Delete cancelled."); } } else { console.error("Invalid delete index:", idx); showToast("Error: Cannot delete fish at invalid index.", 'danger'); } }
        function backFromFishing() { /* ... Uses showPage ... */ console.log("Back from Fishing requested."); stopCameraStream(); showPage('registrationPage'); }


        // --- Camera Functions (Modified for new workflow) ---
        // openCamera now accepts optional fish data to add *after* completion
        async function openCamera(fishId, fishObjectToAdd = null) {
            console.log("Opening camera for fish ID:", fishId);
            currentFishIdForPhoto = fishId; // Still needed for saving image

            const video = document.getElementById('cameraVideo');
            if (!video || !cameraModalInstance) {
                 console.error("Camera video element or modal instance missing!");
                 showToast("Error: Could not initialize camera view.", 'danger');
                 // If camera fails to open, and we intended to add a fish, add it now without photo
                 if (fishObjectToAdd) {
                     console.log("Camera init failed, finalizing fish add without photo.");
                     finalizeAddFish(fishObjectToAdd);
                 }
                 return;
            }
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showToast("Camera access is not supported by your browser or device.", 'warning');
                if (fishObjectToAdd) finalizeAddFish(fishObjectToAdd);
                return;
            }

            // Stop previous stream if any
            if (currentStream) {
                 stopCameraStream();
            }
            video.srcObject = null;

            // Define what happens when camera modal is closed/cancelled
            const cameraCancelHandler = () => {
                 console.log("Camera modal hidden/cancelled.");
                 stopCameraStream();
                 // If we were in the process of adding a fish, add it now without the photo
                 if (fishObjectToAdd && currentFishIdForPhoto === fishId) { // Check if it's the same fish add process
                     console.log("Camera cancelled during add, finalizing fish add without photo.");
                     finalizeAddFish(fishObjectToAdd);
                     currentFishIdForPhoto = null; // Clear ID as process is complete
                 }
                 // Remove this listener to prevent it firing multiple times
                 cameraModalInstance._element.removeEventListener('hidden.bs.modal', cameraCancelHandler);
            };

            // Add listener for modal close/cancel
            cameraModalInstance._element.addEventListener('hidden.bs.modal', cameraCancelHandler, { once: true });


            try {
                const constraints = { video: { facingMode: "environment" } };
                console.log("Requesting camera stream with constraints:", constraints);
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                await video.play();
                cameraModalInstance.show(); // Show modal *before* adding fish
                console.log("Rear camera stream started successfully.");
            } catch (err) {
                console.error("Error accessing rear camera:", err);
                if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                    showToast("Camera permission denied. Please allow camera access.", 'warning');
                } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError" || err.name === "OverconstrainedError") {
                    console.log("Rear camera not found or constraints failed, trying front camera...");
                    try {
                        const frontConstraints = { video: { facingMode: "user" } };
                        currentStream = await navigator.mediaDevices.getUserMedia(frontConstraints);
                        video.srcObject = currentStream;
                        await video.play();
                        cameraModalInstance.show(); // Show modal
                        console.log("Front camera stream started successfully.");
                    } catch (fallbackErr) {
                        console.error("Error accessing front camera:", fallbackErr);
                        showToast(`Could not access any camera. Error: ${fallbackErr.name}`, 'danger');
                         if (fishObjectToAdd) finalizeAddFish(fishObjectToAdd); // Add fish if camera fails
                         cameraModalInstance._element.removeEventListener('hidden.bs.modal', cameraCancelHandler); // Remove listener if modal never shown
                    }
                } else {
                    showToast(`Could not access camera: ${err.name}`, 'danger');
                     if (fishObjectToAdd) finalizeAddFish(fishObjectToAdd); // Add fish if camera fails
                     cameraModalInstance._element.removeEventListener('hidden.bs.modal', cameraCancelHandler); // Remove listener if modal never shown
                }
            }
        }

        function stopCameraStream() { /* ... No change needed ... */ if (currentStream) { console.log("Stopping camera stream tracks."); currentStream.getTracks().forEach(track => track.stop()); } currentStream = null; const video = document.getElementById('cameraVideo'); if (video) video.srcObject = null; console.log("Camera stream stopped."); }

        // takeSnapshot now needs to know if it's part of an addFish flow
        async function takeSnapshot() {
            console.log("Taking snapshot...");
            const video = document.getElementById('cameraVideo');
            const canvas = document.getElementById('cameraCanvas');
            const takePhotoButton = document.getElementById('takePhotoButton');

            if (!video || !canvas || !currentFishIdForPhoto) {
                console.error("Snapshot failed: Missing video, canvas, or fish ID.");
                stopCameraStream();
                hideModal('cameraModal'); // Ensure modal is hidden
                return;
            }
            // Check if a fish add operation is pending for this ID (by checking if it's NOT in fishData yet)
            const isAddingNewFish = !fishData.some(f => f.id === currentFishIdForPhoto);
            let fishObjectToAdd = null;
            if (isAddingNewFish) {
                 // This logic is flawed. The fish data isn't globally available here.
                 // We need to rethink how to pass the fishObjectToAdd through.
                 // -- REVISION --
                 // Let's simplify: openCamera should NOT pass fishObjectToAdd.
                 // Instead, takeSnapshot will save the image ID.
                 // finalizeAddFish will be called by addFish *after* the camera attempt (success or fail).
                 // How does finalizeAddFish get the imageId if successful?
                 // -- REVISION 2 --
                 // 1. addFish validates, creates fishObject (NO imageId yet), generates fishId.
                 // 2. addFish calls openCamera(fishId).
                 // 3. If camera opens: User takes photo OR cancels.
                 // 4. If photo taken (takeSnapshot): Saves image to DB, gets imageId. *Crucially, needs to associate imageId with fishId*. We can update fishData *if the fish is already there* (editing), or store it temporarily if adding.
                 // 5. If camera cancelled (hidden.bs.modal): No imageId.
                 // 6. After camera modal closes (either way): We need to proceed.
                 // -- REVISION 3 (Simpler) --
                 // 1. addFish validates, creates fishObject, generates fishId.
                 // 2. Tries openCamera(fishId).
                 // 3. If camera opens:
                 //    - takeSnapshot: Saves image blob with ID `img_FISHID_timestamp`. DOES NOT modify fishData array yet. Hides modal. Calls `processPhotoResult(fishId, imageId)`.
                 //    - Cancel/Close: Hides modal. Calls `processPhotoResult(fishId, null)`.
                 // 4. If camera doesn't open / error: Calls `processPhotoResult(fishId, null)`.
                 // 5. `processPhotoResult(fishId, imageId)`: Now we have the result. Find the fish in `fishData` (if editing) OR handle the *pending* add.
                 // -- REVISION 4 (Current approach - modify finalizeAddFish) --
                 // 1. addFish validates data, creates fish ID. Does NOT add to fishData yet.
                 // 2. Calls openCamera(fishId, fullFishObject).
                 // 3. openCamera shows modal.
                 // 4. takeSnapshot: Saves image to DB with imageId. Hides modal. Calls finalizeAddFish(fishObjectPassedToCamera, newImageId).
                 // 5. Cancel/Close (hidden.bs.modal): Hides modal. Calls finalizeAddFish(fishObjectPassedToCamera, null).
                 // 6. finalizeAddFish(fishObject, imageId): Sets fishObject.imageId = imageId if provided. Pushes fishObject to fishData. Updates UI.

                 // Let's stick with REVISION 4 for now, modifying openCamera and takeSnapshot/cancel handler.

                // OK, snapshot logic continues...
                if (video.readyState < video.HAVE_METADATA || video.videoWidth === 0) { console.error("Snapshot failed: Video not ready or dimensions 0."); showToast("Camera not ready, please wait.", "warning"); return; }
                if (takePhotoButton) takePhotoButton.disabled = true;

                const MAX_WIDTH = 1280; const MAX_HEIGHT = 1280;
                let width = video.videoWidth; let height = video.videoHeight;
                // ... (resizing logic unchanged) ...
                 if (width > height) { if (width > MAX_WIDTH) { height = Math.round(height * MAX_WIDTH / width); width = MAX_WIDTH; } } else { if (height > MAX_HEIGHT) { width = Math.round(width * MAX_HEIGHT / height); height = MAX_HEIGHT; } }

                canvas.width = width; canvas.height = height;
                const context = canvas.getContext('2d');
                console.log(`Drawing image to canvas. Resized: ${width}x${height}`);
                try {
                    context.drawImage(video, 0, 0, width, height);
                } catch (drawError) {
                    console.error("Error drawing video to canvas:", drawError);
                    showToast("Failed to capture image from camera feed.", 'danger');
                    stopCameraStream(); hideModal('cameraModal'); if (takePhotoButton) takePhotoButton.disabled = false;
                    // Crucially, we need to trigger the 'cancel' flow here for adding fish
                    // Manually trigger hidden.bs.modal? Risky. Let's just call the logic.
                     const cameraCancelHandler = cameraModalInstance._element.listeners?.['hidden.bs.modal']?.[0]; // Hacky way to maybe get the listener
                     if(cameraCancelHandler) cameraCancelHandler(); // Simulate close
                    return;
                }

                stopCameraStream(); // Stop stream after drawing

                canvas.toBlob(async (blob) => {
                    if (blob) {
                        const imageId = `img_${currentFishIdForPhoto}_${Date.now()}`;
                        console.log(`Generated Blob. Saving with ID: ${imageId}`);
                        try {
                             // Save image to DB first
                            await saveImageToDb(imageId, blob);

                             // Find the fish being added/edited (passed via currentFishIdForPhoto)
                            const fishIndex = fishData.findIndex(f => f.id === currentFishIdForPhoto);
                            let oldImageId = null;

                            if (fishIndex !== -1) { // Fish exists (editing photo)
                                oldImageId = fishData[fishIndex].imageId;
                                fishData[fishIndex].imageId = imageId;
                                console.log("Updated existing fishData with new imageId:", fishData[fishIndex]);
                                saveTempSession(); // Save change
                                updateFishLog(); // Update view immediately
                                if (oldImageId && oldImageId !== imageId) {
                                     console.log("Deleting old image:", oldImageId);
                                     await deleteImageFromDb(oldImageId);
                                }
                                showToast("Photo updated successfully.", 'success');
                            } else {
                                // This is part of the NEW fish add flow.
                                // The finalizeAddFish function will be called via the modal hide event listener,
                                // but we need to pass the imageId TO that listener.
                                // Let's store the imageId temporarily.
                                console.log("Photo taken for new fish, storing imageId for finalize step.");
                                cameraModalInstance._element.dataset.capturedImageId = imageId; // Store ID on modal element
                            }

                        } catch (error) {
                            console.error("Error saving image blob to DB or updating fishData:", error);
                            showToast("Failed to save the photo due to a storage error.", 'danger');
                            cameraModalInstance._element.dataset.capturedImageId = undefined; // Clear temp ID on error
                        }
                    } else {
                        console.error("Canvas toBlob failed to generate blob.");
                        showToast("Failed to process captured photo data.", 'danger');
                        cameraModalInstance._element.dataset.capturedImageId = undefined; // Clear temp ID on error
                    }

                    hideModal('cameraModal'); // This will trigger the 'hidden.bs.modal' listener
                    if (takePhotoButton) takePhotoButton.disabled = false;
                    // currentFishIdForPhoto is cleared in the hidden.bs.modal listener after finalizeAddFish runs

                }, 'image/jpeg', 0.85); // End of toBlob callback
        }

         // Revised Camera Cancel Handler (now includes finalizing add fish)
         function setupCameraCancelHandler(fishId, fishObjectToAdd) {
             const handler = () => {
                 console.log("Camera modal hidden/cancelled.");
                 stopCameraStream();

                 // Get the captured image ID (if any) stored by takeSnapshot
                 const capturedImageId = cameraModalInstance._element.dataset.capturedImageId;
                 cameraModalInstance._element.dataset.capturedImageId = undefined; // Clear it

                 // If we were in the process of adding a fish, add it now
                 if (fishObjectToAdd && currentFishIdForPhoto === fishId) {
                     console.log(`Finalizing fish add. Photo captured: ${!!capturedImageId}`);
                     finalizeAddFish(fishObjectToAdd, capturedImageId); // Pass imageId (or null)
                 } else if (capturedImageId) {
                     // If an image was captured but it wasn't for adding a new fish (i.e., editing),
                     // the update should have happened in takeSnapshot already. Log just in case.
                     console.log("Camera closed after capturing photo for existing fish ID:", fishId);
                 }

                 currentFishIdForPhoto = null; // Clear the ID now that the process is complete

                 // Remove this listener
                 cameraModalInstance._element.removeEventListener('hidden.bs.modal', handler);
                 console.log("Camera cancel handler removed.");
             };

              // Remove any previous listener first
             // This requires storing the handler reference if setupCameraCancelHandler can be called multiple times before hide
             // For simplicity, assume bootstrap handles only one 'hidden' listener well, or manage it more robustly if needed.

             cameraModalInstance._element.addEventListener('hidden.bs.modal', handler, { once: true });
             console.log("Camera cancel handler added.");
         }

         // Modify openCamera to use the setup function
         async function openCamera(fishId, fishObjectToAdd = null) {
             console.log("Opening camera for fish ID:", fishId);
             currentFishIdForPhoto = fishId;

             // ... (rest of camera setup, video element checks etc.) ...
             const video = document.getElementById('cameraVideo');
             if (!video || !cameraModalInstance) { /* ... error handling ... */
                  if (fishObjectToAdd) finalizeAddFish(fishObjectToAdd, null); // Add fish if camera fails
                  return;
             }
             // ... (getUserMedia checks etc.) ...
             if (!navigator.mediaDevices?.getUserMedia) { /* ... error handling ... */
                 if (fishObjectToAdd) finalizeAddFish(fishObjectToAdd, null);
                 return;
             }

             if (currentStream) stopCameraStream();
             video.srcObject = null;

             // Setup the cancel/close handler *before* trying to get the stream
             setupCameraCancelHandler(fishId, fishObjectToAdd);

             try {
                 // ... (try environment camera) ...
                 const constraints = { video: { facingMode: "environment" } };
                 currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                 video.srcObject = currentStream; await video.play(); cameraModalInstance.show();
             } catch (err) {
                  // ... (try user camera or handle error) ...
                 if (/* error warrants stopping */ true) {
                     showToast(/* appropriate message */);
                      // If camera fails completely, the hidden.bs.modal listener won't fire.
                      // We need to manually trigger the finalize step here if adding.
                     if (fishObjectToAdd && currentFishIdForPhoto === fishId) {
                          finalizeAddFish(fishObjectToAdd, null);
                          currentFishIdForPhoto = null; // Clear ID
                          // Remove the handler manually since modal won't hide/fire it
                           const handlerRef = cameraModalInstance._element.listeners?.['hidden.bs.modal']?.[0]; // Hacky
                           if(handlerRef) cameraModalInstance._element.removeEventListener('hidden.bs.modal', handlerRef);
                     }
                 }
             }
         }

         // Modify finalizeAddFish to accept optional imageId
         function finalizeAddFish(fishObject, imageId = null) {
              if (!fishObject) { /* ... error handling ... */ return; }

              fishObject.imageId = imageId; // Assign the captured image ID (if any)
              fishData.push(fishObject);
              console.log("Added fish to main data:", fishObject);

              // Reset form...
              // ... (form reset logic) ...
               try { document.getElementById('speciesInput').value = ''; /* etc */ document.getElementById('speciesInput').focus(); } catch(e){}

              updateFishLog(); // Update the table
              saveTempSession(); // Save progress
              showToast(`${fishObject.species} (${fishObject.length}cm) added ${imageId ? 'with photo' : 'to log'}.`, 'success', 3000);
         }


        // --- End Session Modal ---
        function showEndSessionModal() { /* ... Logic unchanged, uses bootstrap modal instance ... */ console.log("End Session button clicked."); if (fishData.length === 0) { if (!confirm("You haven't logged any fish. Do you still want to end and save this empty session?")) { return; } } const modalEl = document.getElementById('endSessionModal'); const verifierSection = document.getElementById('verifierEndModalSection'); const verifierInput = document.getElementById('verifierEndModalInput'); if (!modalEl || !verifierSection || !verifierInput) { console.error("End session modal elements missing!"); showToast("Error preparing end session dialog.", 'danger'); return; } const isCompetition = !!(currentZone && currentPeg); verifierSection.style.display = isCompetition ? 'block' : 'none'; verifierInput.value = ''; verifierInput.classList.remove('is-invalid'); bootstrap.Modal.getOrCreateInstance(modalEl, {backdrop: 'static', keyboard: false}).show(); }
        function confirmEndSession() { /* ... Uses showToast instead of alert ... */ console.log("Confirm End button clicked."); if (!currentAngler || !currentDate || !currentVenue) { showToast("Cannot save session: Missing Angler, Date, or Venue.", 'danger'); hideModal('endSessionModal'); showPage('registrationPage'); return; } const isCompetition = !!(currentZone && currentPeg); let verifierName = null; const verifierInput = document.getElementById('verifierEndModalInput'); if (isCompetition) { if (!verifierInput) { /* error */ return; } verifierName = verifierInput.value.trim(); if (!verifierName) { showToast("Competition Scorecard: Please enter verifier's name.", 'warning'); verifierInput.classList.add('is-invalid'); verifierInput.focus(); return; } verifierInput.classList.remove('is-invalid'); } hideModal('endSessionModal'); console.log("Session validated. Saving final scorecard data with verifier:", verifierName); const sessionData = { currentAngler, currentDate, currentVenue, currentZone: currentZone || null, currentPeg: currentPeg || null, verifier: verifierName, notes: null, fishData: fishData || [], isCompetition: isCompetition }; const id = `scorecard_${Date.now()}`; try { localStorage.setItem(id, JSON.stringify(sessionData)); console.log("Saved final scorecard metadata to localStorage with key:", id); showToast("Scorecard saved successfully!", 'success'); clearTempSession(); resetApp(); showPage('splashScreen'); } catch(e) { console.error("Failed to save final scorecard metadata:", e); let msg = "Save failed. Local storage might be full or disabled."; if(e.name === 'QuotaExceededError') { msg = "Save failed: Local storage is full. Delete older scorecards?";} showToast(msg, 'danger', 7000); showPage('fishingPage'); } }

        // --- Tally Page ---
        function populateTallySummaryFields() { /* ... Logic unchanged ... */ try{ document.getElementById('summaryAngler').textContent=currentAngler||'?'; document.getElementById('summaryDate').textContent=currentDate?formatDate(currentDate):'?'; document.getElementById('summaryVenue').textContent=currentVenue||'?'; document.getElementById('summaryZone').textContent=currentZone||'N/A'; document.getElementById('summaryPeg').textContent=currentPeg||'N/A'; const verifierSpan = document.getElementById('summaryVerifier'); if (verifierSpan) { const savedData = fishData.length > 0 ? fishData : JSON.parse(localStorage.getItem('temp_session') || '{}').fishData || []; const verifierName = savedData.verifier; // Assuming verifier is stored at top level now
         verifierSpan.innerHTML = verifierName ? `<strong>Verified By:</strong> ${verifierName}` : ''; } }catch(e){console.error("Err populating tally summary:", e);} }
        function populateTallyTable() { /* ... Logic unchanged ... */ const tableBody = document.getElementById('tallyTable'); if (!tableBody) { console.error("Tally table body not found."); return; } const speciesSummary = {}; let overallTotalLength = 0; let longestFish = null; fishData.forEach(fish => { const speciesKey = fish.species || "?"; const length = fish.length || 0; speciesSummary[speciesKey] = speciesSummary[speciesKey] || { count: 0, totalLength: 0, lengths: [] }; speciesSummary[speciesKey].count++; speciesSummary[speciesKey].totalLength += length; speciesSummary[speciesKey].lengths.push(length); overallTotalLength += length; if (!longestFish || length > (longestFish.length || 0)) { longestFish = fish; } }); Object.values(speciesSummary).forEach(details => details.lengths.sort((a, b) => a - b)); const sortedSpeciesEntries = Object.entries(speciesSummary).sort(([a], [b]) => a.localeCompare(b)); tableBody.innerHTML = sortedSpeciesEntries.map(([species, details]) => `<tr><td>${species}</td><td>${details.count}</td><td>${details.lengths.length > 0 ? `(${details.lengths.join(', ')})` : '-'}</td><td>${details.totalLength}</td></tr>`).join('') || '<tr><td colspan="4" class="text-center p-3 text-muted">No fish recorded for tally.</td></tr>'; const speciesCount = Object.keys(speciesSummary).length; const points = overallTotalLength + (speciesCount * POINTS_PER_SPECIES); try { document.getElementById('tallyTotalLength').textContent = `${overallTotalLength} cm`; document.getElementById('tallySpeciesCount').textContent = speciesCount; document.getElementById('longestFishSpecies').textContent = longestFish ? (longestFish.species || '?') : 'N/A'; document.getElementById('longestFishLength').textContent = longestFish ? `${longestFish.length || '?'} cm` : '0 cm'; document.getElementById('tallyPointsTotal').textContent = points; } catch(e) { console.error("Error updating tally footer:", e); } }
        function backFromTally() { /* ... Uses showPage ... */ console.log("Back from Tally requested."); showPage('fishingPage'); }

        // --- Saved Scorecards (Lazy Loading & Filtering) ---

        function showScorecardsModal() { /* ... Logic unchanged, uses bootstrap modal instance ... */
            console.log("DEBUG: showScorecardsModal() triggered.");
            const modalEl=document.getElementById('savedScorecardsModal'), listEl=document.getElementById('savedScorecardsList');
            const filterAngler = document.getElementById('filterAngler');
            const filterVenue = document.getElementById('filterVenue');
            const filterDate = document.getElementById('filterDate');

            if(modalEl && listEl && filterAngler && filterVenue && filterDate){
                listEl.innerHTML='<div class="text-center p-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading scorecards...</span></div></div>';
                // Reset filters visually and internally
                filterAngler.value = '';
                filterVenue.value = '';
                filterDate.value = '';
                currentScorecardFilter = { angler: '', venue: '', date: '' };

                try {
                    let mI=bootstrap.Modal.getInstance(modalEl);
                    if(!mI) mI=new bootstrap.Modal(modalEl,{backdrop:'static',keyboard:false});
                    console.log("DEBUG: Showing savedScorecardsModal.");
                    mI.show();
                    // Load scorecards after modal is shown
                    setTimeout(loadScorecards, 50); // Load with default (no) filter
                } catch (modalError) {
                    console.error("Error showing scorecards modal:", modalError);
                    showToast("Error opening saved scorecards viewer.", 'danger');
                }
            } else {
                console.error("ERROR: Scorecard modal/list/filter elements missing.");
                showToast("Error: Cannot display saved scorecards.", 'danger');
            }
        }

        function applyScorecardFilter() {
             const filterAngler = document.getElementById('filterAngler').value.trim().toLowerCase();
             const filterVenue = document.getElementById('filterVenue').value.trim().toLowerCase();
             const filterDate = document.getElementById('filterDate').value; // Keep as YYYY-MM-DD

             currentScorecardFilter = { angler: filterAngler, venue: filterVenue, date: filterDate };
             console.log("Applying scorecard filter:", currentScorecardFilter);
             loadScorecards(); // Reload list with new filter
         }

        function clearScorecardFilter() {
             document.getElementById('filterAngler').value = '';
             document.getElementById('filterVenue').value = '';
             document.getElementById('filterDate').value = '';
             currentScorecardFilter = { angler: '', venue: '', date: '' };
             console.log("Clearing scorecard filter.");
             loadScorecards(); // Reload list with no filter
         }

         // Revised loadScorecards with filtering
        async function loadScorecards() {
            console.log("Loading scorecards from localStorage with filter:", currentScorecardFilter);
            const savedScorecardsList = document.getElementById('savedScorecardsList');
            const olderScorecardsToggleContainer = document.getElementById('olderScorecardsToggleContainer');
            if (!savedScorecardsList || !olderScorecardsToggleContainer) { console.error("CRITICAL: Modal list or toggle container missing!"); return; }

            savedScorecardsList.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading scorecards...</span></div></div>'; // Show loading spinner
            olderScorecardsToggleContainer.innerHTML = '';

            let scorecards = [];
            let loadError = false;
            try {
                const keys = Object.keys(localStorage);
                for (const key of keys) {
                    if (key?.startsWith('scorecard_')) {
                         const dS = localStorage.getItem(key);
                         if (dS) {
                             try {
                                 const data = JSON.parse(dS);
                                 // Basic data check
                                 if (data && data.currentDate && data.currentVenue) {
                                     // Apply Filter Logic
                                    let passesFilter = true;
                                    if (currentScorecardFilter.angler && !(data.currentAngler || '').toLowerCase().includes(currentScorecardFilter.angler)) {
                                        passesFilter = false;
                                    }
                                    if (passesFilter && currentScorecardFilter.venue && !(data.currentVenue || '').toLowerCase().includes(currentScorecardFilter.venue)) {
                                        passesFilter = false;
                                    }
                                    // Date filter: Exact match on YYYY-MM-DD
                                    if (passesFilter && currentScorecardFilter.date && data.currentDate !== currentScorecardFilter.date) {
                                         passesFilter = false;
                                    }

                                    if (passesFilter) {
                                         const tS = parseInt(key.split('_')[1], 10);
                                         if (!isNaN(tS)) {
                                             scorecards.push({ key, data, timestamp: tS });
                                         } else { console.warn("Skipping scorecard with invalid timestamp:", key); }
                                    }
                                 } else { console.warn("Skipping invalid/incomplete scorecard data:", key); }
                             } catch (e) { console.error("Error parsing scorecard JSON:", key, e); }
                         }
                     }
                }
            } catch (e) {
                 console.error("Error reading scorecards from localStorage:", e);
                 savedScorecardsList.innerHTML='<p class="text-danger p-3">Error loading scorecards from storage.</p>';
                 loadError=true;
            }

            if(loadError) return;

            scorecards.sort((a, b) => b.timestamp - a.timestamp); // Sort newest first

            if (scorecards.length === 0) {
                savedScorecardsList.innerHTML = '<p class="text-center text-muted p-4">No saved scorecards found' +
                    (currentScorecardFilter.angler || currentScorecardFilter.venue || currentScorecardFilter.date ? ' matching your filter.' : '.') +
                    '</p>';
                return;
            }

            console.log(`Total scorecards matching filter: ${scorecards.length}`);
            savedScorecardsList.innerHTML = ''; // Clear spinner

            try {
                // Display initial batch or all if less than limit
                const initial = scorecards.slice(0, SCORECARD_DISPLAY_LIMIT);
                initial.forEach(({ key, data }, index) => {
                    // Pass only summary data initially if optimizing heavily,
                    // or pass full data and let createScorecardElement decide.
                    // Let's pass full data for now, and optimize createScorecardElement.
                    const el = createScorecardElement(key, data, index === 0 && !currentScorecardFilter.angler && !currentScorecardFilter.venue && !currentScorecardFilter.date); // Only highlight latest if not filtered
                    if (el) savedScorecardsList.appendChild(el);
                });
            } catch (e) {
                console.error("Error creating initial scorecard elements:", e);
                savedScorecardsList.innerHTML += '<p class="text-danger p-3">Error displaying scorecards.</p>';
            }

            // Handle "Show Older" button
            if (scorecards.length > SCORECARD_DISPLAY_LIMIT) {
                 const olderCount = scorecards.length - SCORECARD_DISPLAY_LIMIT;
                 const showOlderBtn = document.createElement('button');
                 showOlderBtn.id = 'showOlderBtn';
                 showOlderBtn.className = 'btn btn-outline-secondary';
                 showOlderBtn.innerHTML = `<i class="bi bi-chevron-double-down me-1"></i> View ${olderCount} Older Scorecard${olderCount > 1 ? 's' : ''}`;
                 showOlderBtn.onclick = function() {
                     console.log("Show Older Scorecards clicked.");
                     showOlderBtn.disabled = true; // Prevent double click
                     showOlderBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
                     try {
                         const older = scorecards.slice(SCORECARD_DISPLAY_LIMIT);
                         older.forEach(({ key, data }) => {
                             const el = createScorecardElement(key, data, false); // Not latest
                             if (el) savedScorecardsList.appendChild(el);
                         });
                         olderScorecardsToggleContainer.innerHTML = ''; // Remove button after loading
                     } catch(e) {
                         console.error("Error creating/appending older scorecard elements:", e);
                         olderScorecardsToggleContainer.innerHTML = '<p class="text-danger">Error displaying older scorecards.</p>';
                     }
                 };
                 olderScorecardsToggleContainer.appendChild(showOlderBtn);

                 // Add Delete Older button only if not filtered
                 if (!currentScorecardFilter.angler && !currentScorecardFilter.venue && !currentScorecardFilter.date) {
                    const deleteOlderBtn = document.createElement('button');
                    deleteOlderBtn.id = 'deleteOlderBtn';
                    deleteOlderBtn.className = 'btn btn-outline-danger';
                    deleteOlderBtn.innerHTML = '<i class="bi bi-trash me-1"></i> Delete Older';
                    deleteOlderBtn.title = `Delete ${olderCount} oldest scorecards`;
                    deleteOlderBtn.onclick = confirmDeleteOlderScorecards; // Existing function
                    olderScorecardsToggleContainer.appendChild(deleteOlderBtn);
                 }
            }
        }


        // Create Scorecard Element (Revised for Lazy Loading Details)
        function createScorecardElement (key, data, isLatest) {
            try {
                const wrapperDiv = document.createElement('div');
                wrapperDiv.className = `scorecard-entry${isLatest ? ' latest-scorecard' : ''}`;
                wrapperDiv.id = `entry-${key}`;
                wrapperDiv.dataset.scorecardKey = key; // Store key for easy access

                // --- Calculate Summary Info (Needed for Header) ---
                // This still requires iterating fishData, which is the bottleneck.
                // OPTIMIZATION OPTION 1: Store summary counts/totals directly in the saved object `sessionData` in `confirmEndSession`.
                // OPTIMIZATION OPTION 2: Keep current method, assuming scorecards aren't thousands of fish long.
                // Let's stick with Option 2 for now, but be aware this is the place to optimize if list loading is slow.
                let overallTotalLength = 0, fishCount = 0, speciesSet = new Set();
                const fishList = data.fishData || [];
                fishList.forEach(f => {
                    fishCount++;
                    overallTotalLength += (f.length || 0);
                    speciesSet.add(f.species || '?');
                });
                const speciesCount = speciesSet.size;
                const points = overallTotalLength + (speciesCount * POINTS_PER_SPECIES);
                const escapedKey = key.replace(/'/g, "\\'"); // For inline JS onclick attributes

                // --- Build Header ---
                const headerHtml = `
                    <div class="scorecard-item" onclick="toggleScorecardDetails(this)">
                        <i class="bi bi-chevron-right"></i>
                        <div>
                            <strong>${data.currentVenue || '?'}</strong> - ${formatDate(data.currentDate || '')}
                            <small class="text-muted d-block">${fishCount} fish • ${overallTotalLength}cm • ${points} pts • Angler: ${data.currentAngler || '?'}</small>
                        </div>
                        ${isLatest ? '<span class="badge bg-primary ms-auto align-self-center">Latest</span>' : ''}
                    </div>`;

                // --- Details Placeholder ---
                 // Details div is initially empty. Content added by toggleScorecardDetails.
                const detailsHtml = `
                    <div class="scorecard-details" style="display: none;">
                         <!-- Content will be loaded here -->
                         <div class="text-center p-4 details-loading-spinner">
                              <div class="spinner-border text-secondary" role="status">
                                   <span class="visually-hidden">Loading details...</span>
                              </div>
                         </div>
                    </div>`;

                wrapperDiv.innerHTML = headerHtml + detailsHtml;
                return wrapperDiv;

            } catch (elementError) {
                console.error(`Error creating scorecard element header for ${key}:`, elementError);
                 // Return an error placeholder
                 const errDiv = document.createElement('div');
                 errDiv.className = 'scorecard-entry alert alert-warning p-2 my-2';
                 errDiv.textContent = `Error displaying scorecard ${key.slice(-6)}`;
                 return errDiv;
            }
        }

        // Toggle Scorecard Details (Revised for Lazy Loading)
        async function toggleScorecardDetails(headerElement) {
            const wrapperDiv = headerElement.closest('.scorecard-entry');
            if (!wrapperDiv) return;

            const detailsDiv = wrapperDiv.querySelector('.scorecard-details');
            const icon = headerElement.querySelector('i.bi');
            const key = wrapperDiv.dataset.scorecardKey;

            if (!detailsDiv || !icon || !key) {
                console.error("Details div, icon, or key missing for scorecard toggle.", wrapperDiv);
                return;
            }

            const isVisible = detailsDiv.style.display === 'block';

            // Toggle visibility
            detailsDiv.style.display = isVisible ? 'none' : 'block';
            icon.classList.toggle('bi-chevron-right', isVisible);
            icon.classList.toggle('bi-chevron-down', !isVisible);
            headerElement.classList.toggle('details-visible', !isVisible);

            // If revealing and details haven't been loaded yet
            if (!isVisible && !detailsDiv.dataset.detailsLoaded) {
                 console.log("Loading details for scorecard:", key);
                 detailsDiv.querySelector('.details-loading-spinner')?.style.display = 'block'; // Show spinner

                 try {
                     // --- Fetch or Get Data ---
                     // Assuming 'data' was passed fully in loadScorecards initially.
                     // If we optimized loadScorecards to only fetch keys/headers,
                     // we would need to fetch the full data here:
                     // const dataString = localStorage.getItem(key);
                     // const data = dataString ? JSON.parse(dataString) : null;
                     // For now, assume data is available from the initial load:
                     let data = null;
                      // Find the data associated with this key (this assumes `scorecards` array is accessible or we re-fetch)
                      // This is inefficient. Let's re-fetch from localStorage for simplicity.
                      const dataString = localStorage.getItem(key);
                      if (!dataString) throw new Error("Scorecard data not found in localStorage.");
                      data = JSON.parse(dataString);

                     if (!data) {
                         throw new Error("Could not retrieve data for scorecard details.");
                     }

                     // --- Recalculate Summary (if not stored) ---
                     let overallTotalLength = 0, fishCount = 0, speciesSet = new Set(), longestFish = null, speciesTotals = {};
                     const fishList = data.fishData || [];
                     fishList.forEach(f => { /* ... calculation as before ... */
                        const length = f.length || 0; const speciesName = f.species || '?'; fishCount++; overallTotalLength += length; speciesSet.add(speciesName); if (!longestFish || length > (longestFish.length || 0)) longestFish = f; speciesTotals[speciesName] = (speciesTotals[speciesName] || 0) + length;
                     });
                     const speciesCount = speciesSet.size;
                     const points = overallTotalLength + (speciesCount * POINTS_PER_SPECIES);
                     const longestFishString = longestFish ? `${longestFish.species || '?'}(${longestFish.length || '?'}cm)` : 'N/A';

                     // --- Generate Details HTML ---
                     const escapedKey = key.replace(/'/g, "\\'");
                     const hasNotes = data.notes && data.notes.trim() !== '';
                     const viewNoteButtonHtml = hasNotes ? `<button class="btn btn-secondary btn-sm" onclick="viewNote('${escapedKey}', event)"><i class="bi bi-eye me-1"></i>View Note</button>` : '';
                     const addEditNoteButtonHtml = `<button class="btn btn-outline-secondary btn-sm" onclick="openNotesModal('${escapedKey}', event)"><i class="bi bi-pencil me-1"></i>${hasNotes ? 'Edit Note' : 'Add Note'}</button>`;

                     let fishListHtml = `<p class="ms-2 text-muted fst-italic">No fish recorded in this session.</p>`;
                     if (fishList.length > 0) {
                         fishListHtml = fishList.map((f, i) => {
                             let verifiedText = ''; if (data.isCompetition && f.initials) verifiedText = ` <small class="text-muted fst-italic">(Verified: ${f.initials})</small>`;
                             return `<p class="fish-list-item"><span class="badge bg-secondary me-2">${i + 1}</span><span>${f.species || '?'} - <strong>${f.length || '?'}cm</strong></span>${verifiedText}</p>`;
                         }).join('');
                     }

                     let speciesSummaryHtml = '';
                     if (Object.keys(speciesTotals).length > 0) { /* ... species summary generation ... */
                          const sortedSpecies = Object.entries(speciesTotals).sort((a, b) => a[0].localeCompare(b[0])); speciesSummaryHtml += '<div class="species-length-summary"><h6>Species Length Totals:</h6>'; sortedSpecies.forEach(([speciesName, totalLength]) => { speciesSummaryHtml += `<p><strong>${speciesName}:</strong> ${totalLength}cm</p>`; }); speciesSummaryHtml += '</div><hr>';
                     }

                     const photosPlaceholderId = `sessionPhotos-${key}`;
                     const photosHtml = `<hr><h6>Session Photos</h6><div class="session-photos" id="${photosPlaceholderId}"><p class="text-muted placeholder-photos fst-italic">(Loading photos...)</p></div>`;

                     const detailsContentHtml = `
                         <h6>Session Details</h6>
                         <p><strong>Angler:</strong> ${data.currentAngler || '?'}</p>
                         <p><strong>Venue:</strong> ${data.currentVenue || '?'}</p>
                         <p><strong>Date:</strong> ${formatDate(data.currentDate || '')}</p>
                         ${data.currentZone ? `<p><strong>Zone:</strong> ${data.currentZone}</p>` : ''}
                         ${data.currentPeg ? `<p><strong>Peg:</strong> ${data.currentPeg}</p>` : ''}
                         ${data.verifier ? `<p><strong>Verified By:</strong> ${data.verifier}</p>` : ''}
                         <hr>
                         <h6>Catch List (${fishCount})</h6>
                         ${fishListHtml}
                         ${fishList.length > 0 ? `<hr><div class="scorecard-summary-block"><h6>Session Summary</h6>${speciesSummaryHtml}<p><strong>Overall Total Length:</strong> <span class="summary-highlight">${overallTotalLength}cm</span></p><p><strong>Total Species Caught:</strong> ${speciesCount}</p><p><strong>Longest Fish Recorded:</strong> ${longestFishString}</p><p><strong>Points Total (Length + Species Bonus):</strong> <span class="summary-highlight">${points}</span></p></div>` : ''}
                         ${photosHtml}
                         <div class="btn-actions-group">
                             ${viewNoteButtonHtml}
                             ${addEditNoteButtonHtml}
                             <button class="btn btn-info btn-sm" onclick="emailScorecard('${escapedKey}', event)"><i class="bi bi-envelope me-1"></i>Email</button>
                             <button class="btn btn-danger btn-sm" onclick="deleteScorecard('${escapedKey}', event)"><i class="bi bi-trash me-1"></i>Delete</button>
                         </div>`;

                     detailsDiv.innerHTML = detailsContentHtml; // Replace spinner with content
                     detailsDiv.dataset.detailsLoaded = 'true'; // Mark as loaded

                     // --- Load Photos Asynchronously ---
                     loadSessionPhotos(key, fishList); // Existing function call

                 } catch (error) {
                     console.error("Error loading details for scorecard:", key, error);
                     detailsDiv.innerHTML = `<p class="text-danger p-3">Error loading details for this scorecard.</p>`;
                     detailsDiv.dataset.detailsLoaded = 'true'; // Mark as loaded (with error)
                 }
            }

            // Scroll into view if revealing
            if (!isVisible) {
                setTimeout(() => {
                     detailsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100); // Small delay allows display change to render
            }
        }


        async function loadSessionPhotos(scorecardKey, fishList) { /* ... Logic unchanged, but ensures placeholder exists ... */
             const photosContainerId = `sessionPhotos-${scorecardKey}`;
             const photosContainer = document.getElementById(photosContainerId);
             if (!photosContainer) {
                 console.warn(`Photos container not found: ${photosContainerId}. Cannot load photos.`);
                 // Ensure the section doesn't just disappear if the container is missing somehow
                 const detailsDiv = document.getElementById(`details_${scorecardKey}`);
                 if(detailsDiv) {
                    const photoSectionHeader = detailsDiv.querySelector('h6:last-of-type'); // Assuming photos is last
                    if (photoSectionHeader && photoSectionHeader.textContent.includes("Photos")) {
                        photoSectionHeader.insertAdjacentHTML('afterend', '<p class="text-warning fst-italic">(Error finding photo container)</p>');
                    }
                 }
                 return;
             }

             const fishWithPhotos = fishList.filter(f => !!f.imageId);
             if (fishWithPhotos.length === 0) {
                 photosContainer.innerHTML = '<p class="text-muted placeholder-photos fst-italic">(No photos saved for this session)</p>';
                 return;
             }

             console.log(`Loading ${fishWithPhotos.length} photos for scorecard ${scorecardKey}`);
             photosContainer.innerHTML = '<div class="spinner-border spinner-border-sm text-secondary me-2" role="status"></div><span class="text-muted small">Loading photos...</span>';
             let imagesAdded = 0;
             // Use Promise.allSettled for better error handling per image
             const imagePromises = fishWithPhotos.map(async (fish) => { /* ... inner async logic unchanged ... */
                 try { const blob = await getImageFromDb(fish.imageId); if (blob) { const url = URL.createObjectURL(blob); const img = document.createElement('img'); img.src = url; img.alt = `Photo for ${fish.species || 'fish'}`; img.className = 'session-photo-thumbnail'; img.title = `Click to view full size - ${fish.species || 'fish'} (${fish.length || '?'}cm)`; img.onclick = (e) => { e.stopPropagation(); showFullscreenImage(fish.imageId); }; img.addEventListener('load', () => URL.revokeObjectURL(url), { once: true }); img.addEventListener('error', () => console.error(`Error loading image URL: ${url.substring(url.length - 10)}`)); return img; } else { console.warn(`Blob not found in DB for imageId: ${fish.imageId} (scorecard ${scorecardKey})`); return null; } } catch (error) { console.error(`Error loading photo ${fish.imageId} for scorecard ${scorecardKey}:`, error); return null; }
             });

             const results = await Promise.allSettled(imagePromises);

             photosContainer.innerHTML = ''; // Clear loading state
             results.forEach(result => {
                if (result.status === 'fulfilled' && result.value) {
                    photosContainer.appendChild(result.value);
                    imagesAdded++;
                } else if (result.status === 'rejected') {
                    // Logged within the map function
                }
             });

             if (imagesAdded === 0 && fishWithPhotos.length > 0) { photosContainer.innerHTML = '<p class="text-danger placeholder-photos fst-italic">(Error loading session photos)</p>'; }
             else if (imagesAdded === 0) { photosContainer.innerHTML = '<p class="text-muted placeholder-photos fst-italic">(No photos found or loaded)</p>'; }
             console.log(`Finished loading photos for scorecard ${scorecardKey}. Added ${imagesAdded} images.`);
         }


        async function deleteScorecard(key, event){ /* ... Uses showToast ... */ event.stopPropagation(); console.log("Attempting delete for scorecard key:", key); /* ... rest of logic ... */ if (confirm(/*...*/)) { /* ... */ try { /* ... delete images ... */ localStorage.removeItem(key); /* ... remove element ... */ setTimeout(() => { elementToRemove.remove(); loadScorecards(); /* Reload to update list/counts */ }, 300); showToast(`${sN} deleted successfully.`, 'info'); } catch (e) { /*...*/ showToast("Failed to delete scorecard or some images.", 'danger'); loadScorecards(); } } else { /* ... */ } }
        function emailScorecard(key, event) { /* ... Logic unchanged, still uses alert for warning ... */ event.stopPropagation(); console.log("Preparing email for scorecard:", key); alert("Opening email client. Note: Photos & notes are NOT included."); /* ... rest of mailto generation ... */ }

        // --- Notes Modal Functions ---
        function openNotesModal(key, event) { /* ... Logic unchanged ... */ if(event) event.stopPropagation(); console.log('Opening notes modal for key:', key); /* ... */ notesModalInstance.show(); }
        function saveNoteFromModal() { /* ... Uses showToast ... */ console.log('Save notes modal button clicked.'); /* ... */ try { /* ... */ localStorage.setItem(key, JSON.stringify(data)); console.log('Notes saved successfully via modal for key:', key); notesModalInstance.hide(); /* ... Update button text ... */ showToast("Notes saved successfully.", 'success'); } catch (e) { /* ... */ showToast(`Failed to save notes: ${e.message}`, 'danger'); if(e.name === 'QuotaExceededError') { showToast("Local storage full. Notes not saved.", 'danger'); } } }
        function viewNote(key, event) { /* ... Uses alert for display (simple) ... */ event.stopPropagation(); console.log('Viewing notes for key:', key); /* ... */ alert(`Notes for Scorecard:\n--------------------\n${notes.trim() || '(No notes saved yet)'}`); }

        // --- Delete Older Scorecards Functions ---
        function confirmDeleteOlderScorecards() { /* ... Uses SCORECARD_DISPLAY_LIMIT ... */ const displayLimit = SCORECARD_DISPLAY_LIMIT; /* ... rest of logic unchanged ... */ }
        async function deleteOlderScorecards() { /* ... Uses SCORECARD_DISPLAY_LIMIT, showToast ... */ console.log("Starting deletion of older scorecards..."); const displayLimit = SCORECARD_DISPLAY_LIMIT; /* ... */ try { /* ... */ if (keysToDelete.length > 0) { /* ... delete images ... */ keysToDelete.forEach(key => { /* remove metadata */ }); if (errorOccurred) { showToast("Some older scorecards/photos may not have been deleted.", 'warning'); } else { showToast(`${keysToDelete.length} older scorecard${keysToDelete.length > 1 ? 's' : ''} and photos deleted.`, 'info'); } } else { /* ... */ } } catch (e) { /* ... */ showToast("Error deleting older scorecards.", 'danger'); } finally { loadScorecards(); /* Refresh list */ } }

        // --- Image Viewer and Sharing ---
        async function showFullscreenImage(imageId) { /* ... Uses loading state ... */
            console.log("Showing fullscreen image:", imageId);
            if (!imageId || !imageViewerModalInstance) { /* ... error */ return; }
            const imageView = document.getElementById('fullImageView');
            const shareBtn = document.getElementById('shareImageBtn');
            const modalLabel = document.getElementById('imageViewerModalLabel');
            const loadingIndicator = document.getElementById('imageViewerLoading');

            if (!imageView || !shareBtn || !modalLabel || !loadingIndicator) { /* ... error */ return; }

            imageView.style.display = 'none'; // Hide image view
            imageView.src = '#'; // Clear previous image
            loadingIndicator.style.display = 'block'; // Show loading
            shareBtn.disabled = true;
            shareBtn.onclick = null;
            modalLabel.textContent = 'Loading Photo...';
            currentImageBlobForViewer = null;
            currentImageIdForViewer = null;

            imageViewerModalInstance.show();

            try {
                const blob = await getImageFromDb(imageId);
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    imageView.onload = () => {
                        console.log("Fullscreen image loaded:", imageId);
                        modalLabel.textContent = 'Fish Photo';
                        loadingIndicator.style.display = 'none'; // Hide loading
                        imageView.style.display = 'block'; // Show image
                        URL.revokeObjectURL(url); // Revoke URL after load
                    };
                    imageView.onerror = () => { /* ... error handling ... */ modalLabel.textContent = 'Error Loading Photo'; loadingIndicator.style.display = 'none'; };
                    imageView.src = url;

                    currentImageBlobForViewer = blob;
                    currentImageIdForViewer = imageId;
                    const canShare = 'share' in navigator && 'canShare' in navigator;
                    shareBtn.disabled = !canShare;
                    shareBtn.title = canShare ? "Share Image" : "Sharing not supported";
                    if (canShare) { shareBtn.onclick = shareImage; }

                    // Cleanup on hide is handled by Bootstrap events now (added in init)

                } else {
                    showToast("Image data could not be found.", 'warning');
                    loadingIndicator.style.display = 'none';
                    modalLabel.textContent = 'Image Not Found';
                    // Keep modal open briefly to show message? Or hide immediately?
                    // imageViewerModalInstance.hide();
                }
            } catch (error) {
                 console.error("Error loading image for viewer:", error);
                 showToast("Could not load image due to an error.", 'danger');
                 loadingIndicator.style.display = 'none';
                 modalLabel.textContent = 'Load Error';
                 // imageViewerModalInstance.hide();
            }
        }
        async function shareImage() { /* ... Logic unchanged, uses showToast for errors ... */ console.log("Share button clicked for image:", currentImageIdForViewer); /* ... */ if (!navigator.share) { showToast("Web Share API not supported.", 'warning'); /* ... */ return; } /* ... */ try { if (navigator.canShare && navigator.canShare(shareData)) { /* ... */ await navigator.share(shareData); console.log("Image shared successfully."); } else { /* ... */ showToast("Browser cannot share this file type.", 'warning'); } } catch (error) { /* ... */ if (error.name !== 'AbortError') { showToast(`Sharing failed: ${error.message}`, 'danger'); } else { console.log("Sharing cancelled."); } } finally { /* ... */ } }

        // --- General Modal Hiding ---
        function hideModal(modalId) { /* ... Logic unchanged ... */ try { const mE=document.getElementById(modalId); if(mE){const m=bootstrap.Modal.getInstance(mE); if(m){m.hide();} else { /* manual hide fallback */ mE.classList.remove('show'); mE.style.display='none'; const b=document.querySelector('.modal-backdrop.show'); if(b) b.remove(); document.body.classList.remove('modal-open'); document.body.style.overflow=''; document.body.style.paddingRight=''; }} } catch(e) { console.error(`Error hiding modal ${modalId}:`, e); } }
        function showModal(modalId) { /* ... Logic unchanged ... */ try { const modalElement = document.getElementById(modalId); if(modalElement) { const instance = bootstrap.Modal.getOrCreateInstance(modalElement, {backdrop: 'static', keyboard: false}); instance.show(); } else { console.error(`Modal element #${modalId} not found!`); } } catch (e) { console.error(`Error showing modal ${modalId}:`, e); } }

        // --- Application Reset ---
        function resetApp() { /* ... Logic mostly unchanged, ensures FAB hidden ... */
             console.log("Resetting application state and UI...");
             // ... (clear data variables) ...
             fishData=[]; currentAngler=null; currentDate=null; currentVenue=null; currentZone=null; currentPeg=null; currentPage='splashScreen'; stopCameraStream(); deactivateAppMode(); isDropdownPopulated = false; // pendingFishData removed
             // ... (reset form fields) ...
             try { /* ... reset registration/fish forms ... */
                const fab = document.getElementById('addFishFab'); if (fab) fab.classList.add('hidden'); // Hide FAB
                const pageTitle = document.getElementById('pageTitleHeader'); if(pageTitle) pageTitle.textContent = ''; pageTitle.style.display='none';
             } catch(e) {/* ... error handling ... */ }
             console.log("Application reset complete.");
         }


        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DEBUG: DOMContentLoaded event fired. Initializing App...");
            try {
                 await initDb();
                 console.log("DEBUG: IndexedDB initialization complete.");

                 // Service Worker Registration (unchanged)
                 if ('serviceWorker' in navigator) { /* ... */ }

                 // --- Event Listeners ---
                 console.log("DEBUG: Attaching event listeners...");

                 // Navigation State
                 window.addEventListener('popstate', handleBackButton);
                 window.addEventListener('beforeunload', handleBeforeUnload);

                 // Splash Screen Buttons
                 document.getElementById('continueBtn')?.addEventListener('click', startApp);
                 document.getElementById('viewScorecardsBtn')?.addEventListener('click', showScorecardsModal);

                 // Registration Page
                 document.getElementById('startRecordingBtn')?.addEventListener('click', startRecording);
                 document.getElementById('isCompetition')?.addEventListener('change', () => { toggleCompetitionFields(); saveTempSession(); });
                  // Add input listeners for saving temp session (optional, good for robustness)
                 document.getElementById('anglerName')?.addEventListener('input', () => { currentAngler = document.getElementById('anglerName').value.trim(); saveTempSession(); });
                 document.getElementById('competitionDate')?.addEventListener('change', () => { currentDate = document.getElementById('competitionDate').value; saveTempSession(); });
                 document.getElementById('venueInput')?.addEventListener('input', () => { currentVenue = document.getElementById('venueInput').value.trim(); saveTempSession(); });
                 document.getElementById('zoneInput')?.addEventListener('change', () => { currentZone = document.getElementById('isCompetition')?.checked ? document.getElementById('zoneInput').value : null; saveTempSession(); });
                 document.getElementById('pegInput')?.addEventListener('change', () => { currentPeg = document.getElementById('isCompetition')?.checked ? document.getElementById('pegInput').value : null; saveTempSession(); });


                 // Fishing Page
                 document.getElementById('speciesInput')?.addEventListener('change', handleSpeciesSelection); // Handles focus & custom input
                 document.getElementById('speciesInput')?.addEventListener('input', toggleCustomSpeciesInput); // Handle typing 'Other' directly
                 document.getElementById('lengthDecrementBtn')?.addEventListener('click', () => adjustLength(-1));
                 document.getElementById('lengthIncrementBtn')?.addEventListener('click', () => adjustLength(1));
                 document.getElementById('addFishBtnDesktop')?.addEventListener('click', addFish); // Desktop button
                 document.getElementById('addFishFab')?.addEventListener('click', addFish); // FAB button
                 document.getElementById('backFromFishingBtn')?.addEventListener('click', backFromFishing);
                 document.getElementById('endSessionBtn')?.addEventListener('click', showEndSessionModal);

                 // Tally Page
                 document.getElementById('backFromTallyBtn')?.addEventListener('click', backFromTally);

                 // Modals
                 document.getElementById('restoreSessionBtn')?.addEventListener('click', restoreSession);
                 document.getElementById('startNewSessionBtn')?.addEventListener('click', () => { if (confirm("Starting new will discard unsaved data. Sure?")) { startNewSession(); } });
                 document.getElementById('confirmEndBtn')?.addEventListener('click', confirmEndSession);
                 // Notes Save uses inline onclick="saveNoteFromModal()" - keep or change to listener
                 document.querySelector('#notesModal .btn-primary')?.addEventListener('click', saveNoteFromModal); // Alternative to inline
                 document.getElementById('applyScorecardFilterBtn')?.addEventListener('click', applyScorecardFilter);
                 document.getElementById('clearScorecardFilterBtn')?.addEventListener('click', clearScorecardFilter);

                 // Camera / Image Viewer
                 document.getElementById('takePhotoButton')?.addEventListener('click', takeSnapshot);
                 document.getElementById('cancelCameraButtonHeader')?.addEventListener('click', () => hideModal('cameraModal')); // This will trigger the hidden handler
                 // Share button listener added dynamically in showFullscreenImage

                 console.log("DEBUG: Core event listeners attached.");

                 // Initialize Modals and add specific listeners
                 try {
                     const modalIds = ['notesModal', 'cameraModal', 'imageViewerModal', /*'confirmPhotoModal',*/ 'restoreSessionModal', 'savedScorecardsModal', 'endSessionModal', 'mlsInfoModal'];
                     modalIds.forEach(id => {
                         const el = document.getElementById(id);
                         if (el) {
                             const instance = bootstrap.Modal.getOrCreateInstance(el);
                             if (id === 'notesModal') notesModalInstance = instance;
                             if (id === 'cameraModal') cameraModalInstance = instance; // Assign instance
                             if (id === 'imageViewerModal') {
                                imageViewerModalInstance = instance;
                                // Add cleanup for object URL on hide
                                el.addEventListener('hidden.bs.modal', () => {
                                     const imageView = document.getElementById('fullImageView');
                                     if (imageView && imageView.src.startsWith('blob:')) {
                                         console.log("Revoking fullscreen object URL on modal hide:", imageView.src.substring(0, 50) + '...');
                                         URL.revokeObjectURL(imageView.src);
                                         imageView.src = '#'; // Clear src
                                     }
                                      currentImageBlobForViewer = null; // Clear blob ref
                                      currentImageIdForViewer = null;
                                      document.getElementById('shareImageBtn').onclick = null; // Remove listener ref
                                 });
                             }
                             // if (id === 'confirmPhotoModal') confirmPhotoModalInstance = instance; // Removed
                             console.log(`DEBUG: Modal instance created/retrieved for #${id}`);
                         } else { console.warn(`WARN: Modal element #${id} not found!`); }
                     });
                     console.log("DEBUG: Bootstrap modal instances initialized.");
                 } catch (modalInitError) { console.error("ERROR initializing Bootstrap modals:", modalInitError); }


                 // --- Final Setup ---
                 setTodaysDate();
                 checkRestoreSession(); // Start the app flow (shows splash or restore modal)

                 console.log("DEBUG: Sea Catch Scorer initialization sequence complete.");
            } catch (error) {
                 console.error("FATAL ERROR during application initialization:", error);
                 document.body.innerHTML = `<div class="alert alert-danger m-5" role="alert"><strong>Application Initialization Failed!</strong><br> ${error.message}<br>Check console, grant permissions, and refresh.</div>`;
            }
        });
    </script>

</body>
</html>
